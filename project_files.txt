# استخراج ساختار و محتوای فایل‌های پروژه   
# تاریخ: Tue 04/29/2025 22:00:32.42   
   
# ساختار پروژه:   
   
D:\develope\haram_routing\gps_validity\src\App.css
D:\develope\haram_routing\gps_validity\src\App.jsx
D:\develope\haram_routing\gps_validity\src\assets\images\logo.png
D:\develope\haram_routing\gps_validity\src\assets\react.svg
D:\develope\haram_routing\gps_validity\src\components\common\Button.jsx
D:\develope\haram_routing\gps_validity\src\components\common\Input.jsx
D:\develope\haram_routing\gps_validity\src\components\common\Loader.jsx
D:\develope\haram_routing\gps_validity\src\components\layout\Footer.jsx
D:\develope\haram_routing\gps_validity\src\components\layout\Header.jsx
D:\develope\haram_routing\gps_validity\src\components\layout\Menu.jsx
D:\develope\haram_routing\gps_validity\src\components\map\DeadReckoningControls.css
D:\develope\haram_routing\gps_validity\src\components\map\DeadReckoningControls.jsx
D:\develope\haram_routing\gps_validity\src\components\map\DirectionGuide.jsx
D:\develope\haram_routing\gps_validity\src\components\map\LocationTracker.jsx
D:\develope\haram_routing\gps_validity\src\components\map\Map.css
D:\develope\haram_routing\gps_validity\src\components\map\MapView.jsx
D:\develope\haram_routing\gps_validity\src\components\map\QRScanner.jsx
D:\develope\haram_routing\gps_validity\src\components\settings\SettingsForm.jsx
D:\develope\haram_routing\gps_validity\src\components\settings\SettingsPage.jsx
D:\develope\haram_routing\gps_validity\src\contexts\AuthContext.jsx
D:\develope\haram_routing\gps_validity\src\hooks\useGPS.js
D:\develope\haram_routing\gps_validity\src\hooks\useIMUSensors.js
D:\develope\haram_routing\gps_validity\src\hooks\useOfflineStorage.js
D:\develope\haram_routing\gps_validity\src\hooks\useQRCode.js
D:\develope\haram_routing\gps_validity\src\index.css
D:\develope\haram_routing\gps_validity\src\main.jsx
D:\develope\haram_routing\gps_validity\src\pages\HomePage.jsx
D:\develope\haram_routing\gps_validity\src\pages\LoginPage.jsx
D:\develope\haram_routing\gps_validity\src\pages\MapPage.jsx
D:\develope\haram_routing\gps_validity\src\pages\NotFoundPage.jsx
D:\develope\haram_routing\gps_validity\src\pages\QRScanPage.jsx
D:\develope\haram_routing\gps_validity\src\pages\SettingsPage.css
D:\develope\haram_routing\gps_validity\src\pages\SettingsPage.jsx
D:\develope\haram_routing\gps_validity\src\services\AdvancedDeadReckoningService.js
D:\develope\haram_routing\gps_validity\src\services\KalmanFilter.js
D:\develope\haram_routing\gps_validity\src\services\LogStorageService.js
D:\develope\haram_routing\gps_validity\src\services\SignalProcessor.js
D:\develope\haram_routing\gps_validity\src\store\gpsStore.js
D:\develope\haram_routing\gps_validity\src\store\settingsStore.js
D:\develope\haram_routing\gps_validity\src\store\userStore.js
D:\develope\haram_routing\gps_validity\src\styles\DeadReckoning.css
D:\develope\haram_routing\gps_validity\src\utils\constants.js
D:\develope\haram_routing\gps_validity\src\utils\gpsFilter.js
D:\develope\haram_routing\gps_validity\src\utils\helpers.js
D:\develope\haram_routing\gps_validity\src\utils\HighPassFilter.js
D:\develope\haram_routing\gps_validity\src\utils\LowPassFilter.js
D:\develope\haram_routing\gps_validity\src\utils\PeakDetector.js
D:\develope\haram_routing\gps_validity\src\utils\useGPSNoiseDetection.js
D:\develope\haram_routing\gps_validity\src\utils\validation.js
   
# محتوای فایل‌های اصلی:   
   
## \eslint.config.js   
```javascript   
import js from '@eslint/js'
import globals from 'globals'
import reactHooks from 'eslint-plugin-react-hooks'
import reactRefresh from 'eslint-plugin-react-refresh'

export default [
  { ignores: ['dist'] },
  {
    files: ['**/*.{js,jsx}'],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
      parserOptions: {
        ecmaVersion: 'latest',
        ecmaFeatures: { jsx: true },
        sourceType: 'module',
      },
    },
    plugins: {
      'react-hooks': reactHooks,
      'react-refresh': reactRefresh,
    },
    rules: {
      ...js.configs.recommended.rules,
      ...reactHooks.configs.recommended.rules,
      'no-unused-vars': ['error', { varsIgnorePattern: '^[A-Z_]' }],
      'react-refresh/only-export-components': [
        'warn',
        { allowConstantExport: true },
      ],
    },
  },
]
```   
   
## \vite.config.js   
```javascript   
import { defineConfig } from 'vite';  
import react from '@vitejs/plugin-react';  
import { VitePWA } from 'vite-plugin-pwa';  

export default defineConfig({  
  //base: process.env.BASE_URL || '/',  
  base: '/golden_path/',
  plugins: [  
    react(),  
    VitePWA({  
      registerType: 'autoUpdate',  
      includeAssets: ['favicon.ico', 'robots.txt', 'apple-touch-icon.png'],  
      manifest: {  
        name: 'GPS Validity',  
        short_name: 'GPSValid',  
        description: 'اپلیکیشن GPS Validity برای ردیابی موقعیت با دقت بالا',  
        theme_color: '#ffffff',  
        background_color: '#f0f2f5',  
        display: 'standalone',  
        scope: '/',  
        start_url: '/',  
        icons: [  
          {  
            src: '/icons/pwa-192x192.png',  
            sizes: '192x192',  
            type: 'image/png'  
          },  
          {  
            src: '/icons/pwa-512x512.png',  
            sizes: '512x512',  
            type: 'image/png'  
          },  
          {  
            src: '/icons/pwa-512x512.png',  
            sizes: '512x512',  
            type: 'image/png',  
            purpose: 'maskable'  
          }  
        ]  
      },  
      workbox: {  
        globPatterns: ['**/*.{js,css,html,ico,png,svg,json}'],  
        runtimeCaching: [  
          {  
            urlPattern: /^https:\/\/api\.mapbox\.com\/.*/,   
            handler: 'CacheFirst',  
            options: {  
              cacheName: 'mapbox-cache',  
              expiration: {  
                maxEntries: 50,  
                maxAgeSeconds: 60 * 60 * 24 * 30 // 30 روز  
              }  
            }  
          },  
          {  
            urlPattern: /^https:\/\/unpkg\.com\/.*/,   
            handler: 'CacheFirst',  
            options: {  
              cacheName: 'unpkg-cache',  
              expiration: {  
                maxEntries: 10,  
                maxAgeSeconds: 60 * 60 * 24 * 30 // 30 روز  
              }  
            }  
          },  
          {  
            urlPattern: ({ url }) => url.pathname.startsWith('/api/'),  
            handler: 'NetworkFirst',  
            options: {  
              cacheName: 'api-cache',  
              expiration: {  
                maxEntries: 100,  
                maxAgeSeconds: 60 * 60 * 24 // 1 روز  
              },  
              networkTimeoutSeconds: 10  
            }  
          }  
        ]  
      }  
    })  
  ]  
});  ```   
   
## \src\App.jsx   
```javascript   
import React from 'react';  
import { BrowserRouter as Router, Routes, Route, Navigate } from 'react-router-dom';  
import { HomePage } from './pages/HomePage';  
import MapPage from './pages/MapPage';
import { QRScanPage } from './pages/QRScanPage';  
import { SettingsPage } from './pages/SettingsPage';  
import { NotFoundPage } from './pages/NotFoundPage';  
import { Header } from './components/layout/Header';  
import { Footer } from './components/layout/Footer'; 
//import { HashRouter as Router } from 'react-router-dom';  
import './App.css';  

function App() {  
  return (  
    <Router>  
      <div className="app">  
        <Header />  
        <main className="main-content">  
          <Routes>  
            <Route path="/" element={<HomePage />} />  
            <Route path="/map" element={<MapPage />} />  
            <Route path="/qr-scan" element={<QRScanPage />} />  
            <Route path="/settings" element={<SettingsPage />} />  
            <Route path="/404" element={<NotFoundPage />} />  
            <Route path="*" element={<Navigate to="/404" replace />} />  
          </Routes>  
        </main>  
        <Footer />  
      </div>  
    </Router>  
  );  
}  

export default App;  ```   
   
## \src\main.jsx   
```javascript   
import React from 'react';  
import ReactDOM from 'react-dom/client';  
import App from './App.jsx';  
import './index.css';  

// Register service worker for PWA  
if ('serviceWorker' in navigator) {  
  window.addEventListener('load', () => {  
    navigator.serviceWorker.register('/sw.js').then(registration => {  
      console.log('Service Worker registered with scope:', registration.scope);  
    }).catch(error => {  
      console.error('Service Worker registration failed:', error);  
    });  
  });  
}  

ReactDOM.createRoot(document.getElementById('root')).render(  
  <React.StrictMode>  
    <App />  
  </React.StrictMode>,  
);  ```   
   
## \src\App.css   
```javascript   
/* استایل‌های اصلی */  
:root {  
  --primary-color: #3498db;  
  --secondary-color: #2ecc71;  
  --danger-color: #e74c3c;  
  --info-color: #9b59b6;  
  --bg-color: #f5f5f5;  
  --text-color: #333;  
  --header-bg: #fff;  
  --card-bg: #fff;  
  --border-radius: 8px;  
  --shadow: 0 2px 8px rgba(0, 0, 0, 0.15);  
}  

* {  
  box-sizing: border-box;  
  margin: 0;  
  padding: 0;  
}  

body {  
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;  
  background-color: var(--bg-color);  
  color: var(--text-color);  
  direction: rtl;  
  line-height: 1.6;  
}  

.app {  
  display: flex;  
  flex-direction: column;  
  min-height: 100vh;  
}  

.main-content {  
  flex: 1;  
  padding: 20px;  
  max-width: 1200px;  
  margin: 0 auto;  
  width: 100%;  
}  

/* هدر */  
.app-header {  
  background-color: var(--header-bg);  
  padding: 15px 20px;  
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);  
  display: flex;  
  justify-content: space-between;  
  align-items: center;  
}  

.logo a {  
  font-size: 1.5rem;  
  font-weight: bold;  
  color: var(--primary-color);  
  text-decoration: none;  
}  

.main-nav ul {  
  display: flex;  
  list-style: none;  
}  

.main-nav li {  
  margin-left: 20px;  
}  

.main-nav a {  
  text-decoration: none;  
  color: var(--text-color);  
  font-weight: 500;  
  transition: color 0.2s;  
}  

.main-nav a:hover {  
  color: var(--primary-color);  
}  

/* فوتر */  
.app-footer {  
  background-color: var(--header-bg);  
  padding: 15px 20px;  
  text-align: center;  
  box-shadow: 0 -2px 4px rgba(0, 0, 0, 0.05);  
  margin-top: 30px;  
}  

.footer-content {  
  max-width: 1200px;  
  margin: 0 auto;  
  display: flex;  
  justify-content: space-between;  
  align-items: center;  
  flex-wrap: wrap;  
}  

.footer-links {  
  display: flex;  
  gap: 20px;  
}  

.footer-links a {  
  color: var(--text-color);  
  text-decoration: none;  
}  

.footer-links a:hover {  
  color: var(--primary-color);  
}  

/* دکمه‌ها */  
.btn {  
  display: inline-block;  
  padding: 10px 15px;  
  border: none;  
  border-radius: var(--border-radius);  
  background-color: var(--primary-color);  
  color: white;  
  font-size: 16px;  
  cursor: pointer;  
  transition: background-color 0.2s, transform 0.1s;  
  text-align: center;  
  margin: 5px;  
}  

.btn:hover {  
  opacity: 0.9;  
}  

.btn:active {  
  transform: scale(0.98);  
}  

.btn-primary {  
  background-color: var(--primary-color);  
}  

.btn-secondary {  
  background-color: var(--secondary-color);  
}  

.btn-danger {  
  background-color: var(--danger-color);  
}  

.btn-info {  
  background-color: var(--info-color);  
}  

/* صفحه خانه */  
.home-page {  
  max-width: 1000px;  
  margin: 0 auto;  
}  

.hero {  
  text-align: center;  
  padding: 40px 20px;  
  margin-bottom: 30px;  
}  

.hero h1 {  
  font-size: 2.5rem;  
  margin-bottom: 15px;  
  color: var(--primary-color);  
}  

.hero p {  
  font-size: 1.2rem;  
  margin-bottom: 30px;  
  color: #666;  
}  

.hero-buttons {  
  display: flex;  
  justify-content: center;  
  gap: 15px;  
}  

.features {  
  padding: 30px 0;  
}  

.features h2 {  
  text-align: center;  
  margin-bottom: 30px;  
  font-size: 2rem;  
}  

.feature-cards {  
  display: grid;  
  grid-template-columns: repeat(auto-fill, minmax(220px, 1fr));  
  gap: 20px;  
}  

.feature-card {  
  background-color: var(--card-bg);  
  border-radius: var(--border-radius);  
  padding: 25px;  
  box-shadow: var(--shadow);  
  text-align: center;  
}  

.feature-icon {  
  font-size: 2.5rem;  
  margin-bottom: 15px;  
}  

.feature-card h3 {  
  margin-bottom: 10px;  
  font-size: 1.2rem;  
}  

.how-to-use {  
  padding: 40px 0;  
}  

.how-to-use h2 {  
  text-align: center;  
  margin-bottom: 30px;  
  font-size: 2rem;  
}  

.steps {  
  display: grid;  
  grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));  
  gap: 20px;  
}  

.step {  
  background-color: var(--card-bg);  
  border-radius: var(--border-radius);  
  padding: 25px;  
  box-shadow: var(--shadow);  
  position: relative;  
}  

.step-number {  
  background-color: var(--primary-color);  
  color: white;  
  width: 30px;  
  height: 30px;  
  border-radius: 50%;  
  display: flex;  
  align-items: center;  
  justify-content: center;  
  margin-bottom: 15px;  
}  

/* صفحه تنظیمات */  
.settings-page {  
  max-width: 800px;  
  margin: 0 auto;  
  padding: 20px;  
}  

.settings-page h2 {  
  text-align: center;  
  margin-bottom: 30px;  
}  

.settings-form {  
  background-color: var(--card-bg);  
  border-radius: var(--border-radius);  
  padding: 25px;  
  box-shadow: var(--shadow);  
}  

.form-section {  
  margin-bottom: 30px;  
  padding-bottom: 20px;  
  border-bottom: 1px solid #eee;  
}  

.form-section:last-child {  
  border-bottom: none;  
}  

.form-section h3 {  
  margin-bottom: 15px;  
  font-size: 1.3rem;  
  color: var(--primary-color);  
}  

.form-group {  
  margin-bottom: 15px;  
}  

.form-group label {  
  display: block;  
  margin-bottom: 5px;  
  font-weight: 500;  
}  

.form-group input[type="text"],  
.form-group input[type="number"],  
.form-group select {  
  width: 100%;  
  padding: 10px;  
  border: 1px solid #ddd;  
  border-radius: var(--border-radius);  
  font-size: 16px;  
}  

.form-group input[type="checkbox"] {  
  margin-right: 8px;  
}  

.form-group small {  
  display: block;  
  color: #888;  
  margin-top: 5px;  
}  

.form-actions {  
  display: flex;  
  justify-content: space-between;  
  padding-top: 20px;  
}  

/* صفحه نقشه */  
.map-page {  
  height: calc(100vh - 130px);  
  display: flex;  
  flex-direction: column;  
}  

.map-controls {  
  display: flex;  
  justify-content: space-between;  
  margin-bottom: 15px;  
}  

.mode-selector {  
  display: flex;  
  gap: 10px;  
}  

.location-info {  
  background-color: var(--card-bg);  
  padding: 15px;  
  border-radius: var(--border-radius);  
  margin-bottom: 15px;  
  box-shadow: var(--shadow);  
}  

.coordinates {  
  display: grid;  
  grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));  
  gap: 10px;  
}  

.action-buttons {  
  display: flex;  
  justify-content: center;  
  gap: 15px;  
  margin-top: 20px;  
}  

.error-message {  
  background-color: #ffebee;  
  color: var(--danger-color);  
  padding: 10px 15px;  
  border-radius: var(--border-radius);  
  margin-bottom: 15px;  
  border-left: 4px solid var(--danger-color);  
}  

.loading {  
  text-align: center;  
  padding: 10px;  
  color: #777;  
}  

/* صفحه اسکن QR */  
.qr-scan-page {  
  max-width: 800px;  
  margin: 0 auto;  
  padding: 20px;  
}  

.qr-scan-page h2 {  
  text-align: center;  
  margin-bottom: 30px;  
}  

.scanner-container,   
.scan-result-container,  
.start-scan-container,  
.error-container {  
  background-color: var(--card-bg);  
  border-radius: var(--border-radius);  
  padding: 25px;  
  box-shadow: var(--shadow);  
  margin-bottom: 20px;  
  text-align: center;  
}  

.scan-instruction {  
  margin-bottom: 20px;  
  font-weight: 500;  
}  

.scanner-placeholder {  
  height: 300px;  
  display: flex;  
  flex-direction: column;  
  justify-content: center;  
  align-items: center;  
  background-color: #f8f8f8;  
  border-radius: var(--border-radius);  
  gap: 15px;  
}  

.result-data {  
  margin: 20px 0;  
  text-align: left;  
}  

.qr-data {  
  background-color: #f5f5f5;  
  padding: 15px;  
  border-radius: var(--border-radius);  
  margin: 15px 0;  
  word-break: break-all;  
  font-family: monospace;  
}  

.location-data {  
  margin: 15px 0;  
}  

.scan-time {  
  color: #777;  
  font-size: 0.9rem;  
}  

/* صفحه 404 */  
.not-found-page {  
  text-align: center;  
  padding: 50px 20px;  
  max-width: 600px;  
  margin: 0 auto;  
}  

.not-found-page h1 {  
  font-size: 6rem;  
  color: var(--primary-color);  
  margin-bottom: 0;  
}  

.not-found-page h2 {  
  margin-bottom: 20px;  
}  

.not-found-page p {  
  margin-bottom: 30px;  
  color: #777;  
}  


/* استایل‌های نقشه و موقعیت‌یابی */  
.map-page {  
  max-width: 1200px;  
  margin: 0 auto;  
  padding: 15px;  
}  

.map-header {  
  display: flex;  
  flex-direction: column;  
  gap: 10px;  
  margin-bottom: 15px;  
}  

.map-header h2 {  
  margin: 0;  
  color: var(--primary-color);  
}  

.map-controls {  
  display: flex;  
  justify-content: space-between;  
  align-items: center;  
  flex-wrap: wrap;  
  gap: 10px;  
}  

.mode-selector {  
  display: flex;  
  gap: 10px;  
}  

.location-info {  
  background-color: var(--card-bg);  
  padding: 15px;  
  border-radius: var(--border-radius);  
  margin-bottom: 15px;  
  box-shadow: var(--shadow);  
}  

.coordinates {  
  display: grid;  
  grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));  
  gap: 10px;  
}  

.coordinates > div {  
  padding: 8px;  
  background-color: #f8f8f8;  
  border-radius: 4px;  
}  

.map-wrapper {  
  margin-bottom: 15px;  
  border-radius: var(--border-radius);  
  overflow: hidden;  
  box-shadow: var(--shadow);  
}  

.action-buttons {  
  display: flex;  
  flex-wrap: wrap;  
  justify-content: center;  
  gap: 10px;  
  margin: 15px 0;  
}  

.info-panel {  
  background-color: var(--card-bg);  
  padding: 15px;  
  border-radius: var(--border-radius);  
  margin-top: 15px;  
  box-shadow: var(--shadow);  
}  

.info-panel h3 {  
  margin-top: 0;  
  margin-bottom: 15px;  
  color: var(--primary-color);  
  font-size: 1.2rem;  
}  

.stats {  
  display: grid;  
  grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));  
  gap: 15px;  
}  

.stat-item {  
  display: flex;  
  flex-direction: column;  
  padding: 10px;  
  background-color: #f8f8f8;  
  border-radius: 4px;  
}  

.stat-label {  
  font-size: 0.9rem;  
  color: #666;  
  margin-bottom: 5px;  
}  

.stat-value {  
  font-weight: bold;  
  font-size: 1.1rem; /* یا می‌توانید از واحدهای دیگر مانند em, px استفاده کنید */ 
}

/* ===== Login Page Styles ===== */
.login-container {
  max-width: 450px;
  margin: 0 auto;
  padding: 30px 20px;
  text-align: center;
  direction: rtl;
}

.login-logo {
  margin-bottom: 30px;
}

.logo-image {
  height: 80px;
  width: auto;
}

.login-title {
  font-size: 1.8rem;
  color: var(--primary-color);
  margin-bottom: 15px;
}

.login-subtitle {
  color: #666;
  margin-bottom: 30px;
  line-height: 1.6;
}

.login-form {
  margin: 30px 0;
}

.form-group {
  margin-bottom: 25px;
  text-align: right;
}

.form-group label {
  display: block;
  margin-bottom: 8px;
  font-weight: 500;
}

.phone-input {
  width: 100%;
  padding: 12px 15px;
  border: 1px solid #ddd;
  border-radius: var(--border-radius);
  font-size: 16px;
  text-align: right;
  transition: var(--transition);
}

.phone-input:focus {
  border-color: var(--primary-color);
  outline: none;
  box-shadow: 0 0 0 3px rgba(52, 152, 219, 0.2);
}

.submit-btn {
  background-color: var(--primary-color);
  color: white;
  border: none;
  padding: 12px 30px;
  border-radius: var(--border-radius);
  font-size: 16px;
  cursor: pointer;
  width: 100%;
  transition: var(--transition);
}

.submit-btn:hover {
  background-color: #2980b9;
}

.submit-btn:disabled {
  background-color: #95a5a6;
  cursor: not-allowed;
}

.login-terms {
  margin-top: 30px;
  color: #777;
  font-size: 0.9rem;
}

.login-terms a {
  color: var(--primary-color);
  text-decoration: none;
}

.login-terms a:hover {
  text-decoration: underline;
}

/* Responsive */
@media (max-width: 480px) {
  .login-container {
    padding: 20px 15px;
  }
  
  .login-title {
    font-size: 1.5rem;
  }
}```   
   
## \src\index.css   
```javascript   
/* فایل index.css برای استایل‌های پایه */  
@import url('https://fonts.googleapis.com/css2?family=Vazirmatn:wght@400;500;700&display=swap');  

:root {  
  font-family: 'Vazirmatn', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;  
}  

body {  
  margin: 0;  
  padding: 0;  
  box-sizing: border-box;  
  direction: rtl;  
}  

/* استایل اسکرول‌بار */  
::-webkit-scrollbar {  
  width: 8px;  
}  

::-webkit-scrollbar-track {  
  background: #f1f1f1;  
}  

::-webkit-scrollbar-thumb {  
  background: #888;  
  border-radius: 4px;  
}  

::-webkit-scrollbar-thumb:hover {  
  background: #555;  
}  ```   
   
## \src\components\common\Button.jsx   
```javascript   
// Button.jsx  
import React from 'react';  

const Button = ({ children, type = 'button', className = '', onClick, disabled = false }) => {  
  const buttonClassName = `btn ${className}`;  
  
  return (  
    <button   
      type={type}   
      className={buttonClassName}  
      onClick={onClick}  
      disabled={disabled}  
    >  
      {children}  
    </button>  
  );  
};  

export default Button;  ```   
   
## \src\components\common\Input.jsx   
```javascript   

// Input.jsx  
import React from 'react';  

const Input = ({   
  type = 'text',   
  name,   
  value,   
  onChange,   
  placeholder = '',   
  label,   
  error,   
  className = ''   
}) => {  
  return (  
    <div className={`form-group ${className}`}>  
      {label && <label htmlFor={name}>{label}</label>}  
      <input  
        type={type}  
        id={name}  
        name={name}  
        value={value}  
        onChange={onChange}  
        placeholder={placeholder}  
        className={error ? 'error' : ''}  
      />  
      {error && <small className="error-text">{error}</small>}  
    </div>  
  );  
};  

export default I```   
   
## \src\components\common\Loader.jsx   
```javascript   
// Loader.jsx  
import React from 'react';  

const Loader = ({ size = 'medium' }) => {  
  const loaderClass = `loader loader-${size}`;  
  
  return (  
    <div className={loaderClass}>  
      <div className="spinner"></div>  
    </div>  
  );  
};  

export default Loader;  ```   
   
## \src\components\layout\Footer.jsx   
```javascript   
import React from 'react';  

export const Footer = () => {  
  return (  
    <footer className="app-footer">  
      <div className="footer-content">  
        <p>© {new Date().getFullYear()} مسیر طلایی - تمامی حقوق محفوظ است</p>  
        <div className="footer-links">  
          <a href="#" target="_blank" rel="noopener noreferrer">درباره ما</a>  
          <a href="#" target="_blank" rel="noopener noreferrer">تماس با ما</a>  
          <a href="#" target="_blank" rel="noopener noreferrer">حریم خصوصی</a>  
        </div>  
      </div>  
    </footer>  
  );  
};  

// سطر زیر اضافه نشود - به جای آن از { Footer } در import استفاده شود  
// export default Footer;  ```   
   
## \src\components\layout\Header.jsx   
```javascript   
import React from 'react';  
import { Link } from 'react-router-dom';  

export const Header = () => {  
  return (  
    <header className="app-header">  
      <div className="logo">  
        <Link to="/">مسیر طلایی</Link>  
      </div>  
      <nav className="main-nav">  
        <ul>  
          <li><Link to="/">خانه</Link></li>  
          <li><Link to="/map">نقشه</Link></li>  
          <li><Link to="/qr-scan">اسکن QR</Link></li>  
          <li><Link to="/settings">تنظیمات</Link></li>  
        </ul>  
      </nav>  
    </header>  
  );  
};  

// سطر زیر اضافه نشود - به جای آن از { Header } در import استفاده شود  
// export default Header;  ```   
   
## \src\components\map\DeadReckoningControls.jsx   
```javascript   
import React, { useState, useEffect } from 'react';  
import advancedDeadReckoningService from '../../services/AdvancedDeadReckoningService';  
import useIMUSensors from '../../hooks/useIMUSensors';  
import './DeadReckoningControls.css';  

const DeadReckoningControls = ({ currentLocation }) => {  
  const [isActive, setIsActive] = useState(false);  
  const [isCalibrating, setIsCalibrating] = useState(false);  
  const [stepCount, setStepCount] = useState(0);  
  const [strideLength, setStrideLength] = useState(0.75);  
  const [kalmanState, setKalmanState] = useState(null);   
  const [stepCountErrorShown, setStepCountErrorShown] = useState(false);  

  const {   
    acceleration,   
    rotationRate,   
    orientation,   
    isSupported,   
    hasPermission,  
    requestPermission,  
    checkPermissions  
  } = useIMUSensors();  

  // اضافه کردن listener به سرویس جدید  
  useEffect(() => {  
    const removeListener = advancedDeadReckoningService.addListener((data) => {  
      setIsActive(data.isActive);  
      setIsCalibrating(data.isCalibrating);  
      setStepCount(data.stepCount);  
      setKalmanState(data.kalmanState);  
      
      // اگر در حالت فعال سرویس و کالیبراسیون نیستیم ولی گام نرفته، alert بده  
      if(data.isActive && !data.isCalibrating && data.stepCount === 0 && !stepCountErrorShown){  
        alert('توجه: گام برداری ثبت نمی‌شود. مطمئن شوید دستگاه حرکت دارد و سنسورها فعال هستند.');  
        setStepCountErrorShown(true);  
      }  

      // اگر گام ثبت شده، خطا را غیرفعال کن  
      if(data.stepCount > 0){  
        setStepCountErrorShown(false);  
      }  
    });  
    
    return () => removeListener();  
  }, [stepCountErrorShown]);  

  // ارسال داده‌های سنسور به سرویس  
  useEffect(() => {  
    if (isActive && hasPermission) {  
      const timestamp = Date.now();  
      if (acceleration) advancedDeadReckoningService.processAccelerometerData(acceleration, timestamp);  
      if (rotationRate) advancedDeadReckoningService.processGyroscopeData(rotationRate, timestamp);  
      if (orientation) advancedDeadReckoningService.processOrientationData(orientation, timestamp);  
    }  
  }, [isActive, hasPermission, acceleration, rotationRate, orientation]);  

  // ارسال داده‌های GPS به سرویس  
  useEffect(() => {  
    if (isActive && currentLocation?.coords) {  
      advancedDeadReckoningService.processGpsData(  
        { lat: currentLocation.coords.lat, lng: currentLocation.coords.lng },  
        currentLocation.coords.accuracy,  
        Date.now()  
      );  
    }  
  }, [isActive, currentLocation]);  

  const handleToggle = async () => {  
    if (!isActive) {  
      if (!isSupported) {  
        alert('سنسورهای دستگاه پشتیبانی نمی‌شوند.');  
        return;  
      }  
      
      if (!checkPermissions()) {  
        const permissionGranted = await requestPermission();  
        if (!permissionGranted) {  
          alert('برای استفاده، دسترسی به سنسورها را فعال کنید.');  
          return;  
        }  
      }  
      
      const initialLatLng = currentLocation?.coords ? {  
        lat: currentLocation.coords.lat,  
        lng: currentLocation.coords.lng  
      } : null;  
      
      advancedDeadReckoningService.toggle(initialLatLng);  
    } else {  
      advancedDeadReckoningService.toggle();  
    }  
  };  

  const handleReset = () => {  
    advancedDeadReckoningService.reset();  
  };  

  const handleExport = () => {  
    advancedDeadReckoningService.exportLog();  
  };  

  const handleStrideLengthChange = (e) => {  
    const newValue = parseFloat(e.target.value);  
    setStrideLength(newValue);  
    advancedDeadReckoningService.setStrideLength(newValue);  
  };  

  return (  
    <div className="dead-reckoning-panel">  
      <div className="dr-header">  
        <h3>Advanced Dead Reckoning</h3>  
      </div>  
      
      {isCalibrating && (  
        <div className="calibrating-status">درحال کالیبراسیون سنسورها...</div>  
      )}  
      
      <div className="dr-button-group">  
        <button   
          className={`dr-button dr-button-start ${isActive ? 'active' : ''}`}   
          onClick={handleToggle}  
          disabled={!isSupported || (!isActive && !hasPermission && typeof DeviceMotionEvent.requestPermission === 'function')}  
        >  
          {isActive ? 'توقف ردیابی پیشرفته' : 'شروع ردیابی پیشرفته'}  
        </button>  
        
        <button   
          className="dr-button dr-button-reset"   
          onClick={handleReset}  
          disabled={!isActive}  
        >  
          بازنشانی سیستم  
        </button>  
        
        <button   
          className="dr-button dr-button-export"   
          onClick={handleExport}  
          disabled={stepCount === 0 && !kalmanState}  
        >  
          خروجی لاگ  
        </button>  
      </div>  
      
      <div className="dr-step-count">  
        تعداد گام‌ها: {stepCount}  
      </div>  
      
      <div className="dr-stride-control">  
        <label className="dr-stride-label">  
          طول گام (متر):  
        </label>  
        <input   
          type="range"   
          min="0.3"   
          max="1.2"   
          step="0.05"   
          value={strideLength}   
          onChange={handleStrideLengthChange}   
          className="dr-stride-slider"  
          disabled={!isActive}  
        />  
        <div className="dr-stride-value">{strideLength.toFixed(2)}</div>  
      </div>  
       {/* نمایش وضعیت فیلتر کالمن برای دیباگ */}  
       {kalmanState && (  
           <div style={{ fontSize: '12px', marginTop: '10px' }}>  
               <p>موقعیت نسبی: ({kalmanState.x.toFixed(2)}, {kalmanState.y.toFixed(2)}) متر</p>  
               <p>جهت (درجه): {(kalmanState.theta * 180 / Math.PI).toFixed(2)}</p>  
               <p>سرعت خطی: {kalmanState.v.toFixed(2)} متر بر ثانیه</p>  
               <p>سرعت زاویه‌ای: {(kalmanState.w * 180 / Math.PI).toFixed(2)} درجه بر ثانیه</p>  
               <p>طول گام تخمینی: {kalmanState.stride.toFixed(2)} متر</p>  
           </div>  
       )}  
    </div>  
  );  
};  

export default DeadReckoningControls;  ```   
   
## \src\components\map\MapView.jsx   
```javascript   
// src/components/map/MapView.jsx  
import React, { useEffect, useState } from 'react';
import { MapContainer, TileLayer, Marker, Popup, Circle, Polyline, useMap, ZoomControl } from 'react-leaflet';
import DeadReckoningControls from './DeadReckoningControls';

import L from 'leaflet';
import 'leaflet/dist/leaflet.css';
import './Map.css';
// import AdvancedDeadReckoningControls from './DeadReckoningControls';
import advancedDeadReckoningService from '../../services/AdvancedDeadReckoningService';

// حل مشکل آیکون‌های Leaflet  
delete L.Icon.Default.prototype._getIconUrl;
L.Icon.Default.mergeOptions({
  iconUrl: 'https://unpkg.com/leaflet@1.7.1/dist/images/marker-icon.png',
  iconRetinaUrl: 'https://unpkg.com/leaflet@1.7.1/dist/images/marker-icon-2x.png',
  shadowUrl: 'https://unpkg.com/leaflet@1.7.1/dist/images/marker-shadow.png',
});

// آیکون موقعیت فعلی GPS (آبی)  
const currentLocationIcon = new L.Icon({
  iconUrl: 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyNCAyNCIgZmlsbD0iIzAwODVmZiIgd2lkdGg9IjI0cHgiIGhlaWdodD0iMjRweCI+PHBhdGggZD0iTTAgMGgyNHYyNEgweiIgZmlsbD0ibm9uZSIvPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjgiLz48L3N2Zz4=',
  iconSize: [24, 24],
  iconAnchor: [12, 12],
  popupAnchor: [0, -12],
});

// آیکون Dead Reckoning (قرمز)  
const drLocationIcon = new L.Icon({
  iconUrl: 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyNCAyNCIgZmlsbD0iI2U1MzkzNSIgd2lkdGg9IjI0cHgiIGhlaWdodD0iMjRweCI+PHBhdGggZD0iTTAgMGgyNHYyNEgweiIgZmlsbD0ibm9uZSIvPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjgiLz48L3N2Zz4=',
  iconSize: [24, 24],
  iconAnchor: [12, 12],
  popupAnchor: [0, -12],
});

/// آیکون جهت‌دار برای نمایش heading Dead Reckoning  
const headingArrowIcon = (headingInDegrees) => new L.Icon({
  iconUrl: `data:image/svg+xml;base64,${btoa(`<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24">  
    <path fill="red" transform="rotate(${headingInDegrees}, 12, 12)" d="M12,2L4.5,20.29L5.21,21L12,18L18.79,21L19.5,20.29L12,2Z"/>  
  </svg>`)}`,
  iconSize: [32, 32],
  iconAnchor: [16, 16],
  popupAnchor: [0, -16],
});

// کامپوننت کنترل خودکار مرکز نقشه  
const AutoCenterMap = ({ position, follow }) => {
  const map = useMap();

  useEffect(() => {
    if (position && follow) {
      map.setView(position, map.getZoom());
    }
  }, [position, follow, map]);

  return null;
};

const MapView = ({
  currentLocation,
  locationHistory = [],
  savedLocations = [],
  followUser = true,
  initialZoom = 15
}) => {
  const [map, setMap] = useState(null);
  const [isFollowing, setIsFollowing] = useState(followUser);
  const [isDrActive, setIsDrActive] = useState(advancedDeadReckoningService.isActive);
  const [drGeoPath, setDrGeoPath] = useState([]);
  const [kalmanState, setKalmanState] = useState(null);
  const [drPosition, setDrPosition] = useState(null);
  const [stepCount, setStepCount] = useState(0);
  // const [headingInDegrees, setHeadingInDegrees] = useState(0);  


  // موقعیت مرکز نقشه (یا موقعیت فعلی GPS یا موقعیت DR)  
  const centerPosition = drPosition && isFollowing && isDrActive
    ? [drPosition.lat, drPosition.lng]
    : currentLocation?.coords
      ? [currentLocation.coords.lat, currentLocation.coords.lng]
      : null;

  // مسیر GPS طی شده  
  const pathPoints = locationHistory
    .filter(loc => loc?.coords?.lat && loc?.coords?.lng)
    .map(loc => [loc.coords.lat, loc.coords.lng]);

  // اضافه کردن listener برای Advanced Dead Reckoning Service  
  useEffect(() => {
    const removeListener = advancedDeadReckoningService.addListener((data) => {
      // به‌روزرسانی وضعیت فعال بودن سرویس  
      setIsDrActive(data.isActive);

      if (data.type === 'step' || data.type === 'serviceStateChanged') {
        // به‌روزرسانی شمارنده گام  
        if (data.stepCount !== undefined && data.stepCount !== null) {
          setStepCount(data.stepCount);
          alert('Step Count updated');  

        }

        // به‌روزرسانی وضعیت کالمن  
        if (data.kalmanState) {
          setKalmanState(data.kalmanState);
          // محاسبه جهت به درجه  
          const headingRad = data.kalmanState.theta;
          // setHeadingInDegrees(((headingRad * 180 / Math.PI) + 360) % 360);
        }

        // به‌روزرسانی موقعیت تخمینی  
        if (data.geoPosition) {
          // بررسی اعتبار موقعیت  
          if (!isNaN(data.geoPosition.lat) && !isNaN(data.geoPosition.lng)) {
            console.log('Updating DR position:', data.geoPosition);
            setDrPosition(data.geoPosition);
          }
        }

        // به‌روزرسانی مسیر جغرافیایی Dead Reckoning  
        if (data.geoPath && data.geoPath.length > 0) {
          const formattedPath = data.geoPath.map(point => {
            if (isNaN(point.lat) || isNaN(point.lng)) {
              return null;
            }
            return [point.lat, point.lng];
          }).filter(point => point !== null);

          setDrGeoPath(formattedPath);
        }
      }
    });

    return () => removeListener();
  }, []);

  // ارسال داده‌های GPS به سرویس  
  useEffect(() => {
    if (isDrActive && currentLocation?.coords) {
      advancedDeadReckoningService.processGpsData(
        { lat: currentLocation.coords.lat, lng: currentLocation.coords.lng },
        currentLocation.coords.accuracy,
        Date.now()
      );
    }
  }, [isDrActive, currentLocation]);

  // تغییر وضعیت تعقیب کاربر  
  const toggleFollow = () => {
    setIsFollowing(prev => !prev);
    if (!isFollowing && centerPosition && map) {
      map.setView(centerPosition, map.getZoom() || initialZoom);
    }
  };

  // محاسبه مرکز اولیه نقشه  
  const getInitialCenter = () => {
    if (currentLocation?.coords) {
      return [currentLocation.coords.lat, currentLocation.coords.lng];
    }
    if (locationHistory.length > 0 && locationHistory[0]?.coords) {
      return [locationHistory[0].coords.lat, locationHistory[0].coords.lng];
    }
    // مرکز پیش‌فرض - تهران  
    return [35.6892, 51.3890];
  };

  // تبدیل جهت رادیان به درجه (برای نمایش فلش)  
  const headingInDegrees = kalmanState?.theta !== undefined
    ? ((kalmanState.theta * 180 / Math.PI) + 360) % 360
    : 0;

  return (
    <div className="map-fullscreen">
      <MapContainer
        center={getInitialCenter()}
        zoom={initialZoom}
        className="map-container"
        whenCreated={setMap}
        zoomControl={false}
      >
        <ZoomControl position="topright" />

        <TileLayer
          attribution='&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
          url="https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png"
        />

        {/* نمایش موقعیت فعلی کاربر (از GPS) */}
        {currentLocation?.coords && (
          <>
            <Marker
              position={[currentLocation.coords.lat, currentLocation.coords.lng]}
              icon={currentLocationIcon}
              zIndexOffset={500}
            >
              <Popup>
                <div>
                  <h3>موقعیت GPS</h3>
                  <p>طول جغرافیایی: {currentLocation.coords.lng.toFixed(6)}</p>
                  <p>عرض جغرافیایی: {currentLocation.coords.lat.toFixed(6)}</p>
                  <p>دقت: {currentLocation.coords.accuracy.toFixed(1)} متر</p>
                </div>
              </Popup>
            </Marker>

            {/* دایره دقت GPS */}
            <Circle
              center={[currentLocation.coords.lat, currentLocation.coords.lng]}
              radius={currentLocation.coords.accuracy}
              color="#0085ff"
              fillColor="#0085ff"
              fillOpacity={0.1}
              weight={1}
            />
          </>
        )}

        {/* نمایش موقعیت تخمینی Dead Reckoning */}
        {isDrActive && drPosition && !isNaN(drPosition.lat) && !isNaN(drPosition.lng) && (
          <>
            <Marker
              position={[drPosition.lat, drPosition.lng]}
              icon={drLocationIcon}
              zIndexOffset={600}
            >
              <Popup>
                <div>
                  <h3>موقعیت تخمینی (DR)</h3>
                  <p>طول جغرافیایی: {drPosition.lng.toFixed(6)}</p>
                  <p>عرض جغرافیایی: {drPosition.lat.toFixed(6)}</p>
                  {kalmanState && (
                    <>
                      <p>جهت (درجه): {headingInDegrees.toFixed(2)}</p>
                      <p>سرعت: {kalmanState.v.toFixed(2)} متر بر ثانیه</p>
                      <p>طول گام: {kalmanState.stride.toFixed(2)} متر</p>
                    </>
                  )}
                </div>
              </Popup>
            </Marker>

            {/* فلش جهت‌دار */}
            {kalmanState?.theta !== undefined && (
              <Marker
                position={[drPosition.lat, drPosition.lng]}
                icon={headingArrowIcon(headingInDegrees)}
                zIndexOffset={1000}
              />
            )}
          </>
        )}

        {/* مسیر GPS طی شده */}
        {pathPoints.length > 1 && (
          <Polyline
            positions={pathPoints}
            color="#0085ff"
            weight={3}
            opacity={0.7}
          />
        )}

        {/* مسیر Dead Reckoning */}
        {isDrActive && drGeoPath.length > 1 && (
          <Polyline
            positions={drGeoPath.filter(point =>
              !isNaN(point[0]) && !isNaN(point[1])
            )}
            color="#e53935"
            weight={3}
            opacity={0.7}
          />
        )}

        {/* نقاط ذخیره شده */}
        {savedLocations.map((location, index) => (
          <Marker
            key={location.id || index}
            position={[location.coords.lat, location.coords.lng]}
          >
            <Popup>
              <div>
                <h3>{location.name || `نقطه ${index + 1}`}</h3>
                <p>طول جغرافیایی: {location.coords.lng.toFixed(6)}</p>
                <p>عرض جغرافیایی: {location.coords.lat.toFixed(6)}</p>
                {location.timestamp && <p>زمان: {new Date(location.timestamp).toLocaleString()}</p>}
              </div>
            </Popup>
          </Marker>
        ))}

        {/* تنظیم خودکار مرکز نقشه */}
        {centerPosition && <AutoCenterMap position={centerPosition} follow={isFollowing} />}
      </MapContainer>

      {/* دکمه‌های کنترل نقشه */}
      <div className="map-controls-overlay">
        {/* دکمه تعقیب موقعیت */}
        <button
          className={`map-control-button ${isFollowing ? 'active' : ''}`}
          onClick={toggleFollow}
          title={isFollowing ? 'توقف تعقیب موقعیت' : 'تعقیب موقعیت'}
        >
          <svg viewBox="0 0 24 24" width="20" height="20" stroke="currentColor" strokeWidth="2" fill="none" strokeLinecap="round" strokeLinejoin="round">
            <circle cx="12" cy="12" r="10"></circle>
            <circle cx="12" cy="12" r="3"></circle>
          </svg>
        </button>

        {/* دکمه مرکز به موقعیت فعلی */}
        <button
          className="map-control-button"
          onClick={() => {
            if (centerPosition && map) {
              map.setView(centerPosition, map.getZoom());
              setIsFollowing(true);
            }
          }}
          title="مرکز به موقعیت فعلی"
        >
          <svg viewBox="0 0 24 24" width="20" height="20" stroke="currentColor" strokeWidth="2" fill="none" strokeLinecap="round" strokeLinejoin="round">
            <line x1="12" y1="2" x2="12" y2="6"></line>
            <line x1="12" y1="18" x2="12" y2="22"></line>
            <line x1="2" y1="12" x2="6" y2="12"></line>
            <line x1="18" y1="12" x2="22" y2="12"></line>
            <circle cx="12" cy="12" r="4"></circle>
          </svg>
        </button>
      </div>

      {/* پنل اطلاعات موقعیت */}
      {currentLocation?.coords && (
        <div className="location-panel">
          <div className="coordinates-display">
            <div>
              <span>عرض:</span> {currentLocation.coords.lat.toFixed(6)}
            </div>
            <div>
              <span>طول:</span> {currentLocation.coords.lng.toFixed(6)}
            </div>
            <div>
              <span>دقت:</span> {currentLocation.coords.accuracy.toFixed(1)} متر
            </div>
          </div>
        </div>
      )}

      {/* پنل کنترل‌های Dead Reckoning */}
      <DeadReckoningControls currentLocation={currentLocation} />
    </div>
  );
};

export default MapView;  ```   
   
## \src\components\map\QRScanner.jsx   
```javascript   
import React, { useState, useEffect } from 'react';  
// import { QrReader } from '@yudiel/react-qr-scanner'; // خط قبلی را کامنت کنید  
import * as QrScannerStuff from '@yudiel/react-qr-scanner'; // همه چیز را وارد کنید  
import { useGPSStore } from '../../store/gpsStore';  
import useGPS from '../../hooks/useGPS';  

const QRScanner = ({ onSuccess, onError }) => {  
  useEffect(() => {  
    console.log("QrScannerStuff:", QrScannerStuff); // ببینیم چه چیزهایی داخلش هست  
  }, []);  

  return <div>Testing QR Scanner Import... Check console (F12).</div>;  
};  

export default QRScanner;  ```   
   
## \src\components\map\DeadReckoningControls.css   
```javascript   
.dead-reckoning-panel {  
    position: absolute;  
    top: 80px;  
    right: 10px;  
    background-color: white;  
    border-radius: 8px;  
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);  
    width: 220px;  
    padding: 12px;  
    z-index: 1000;  
    direction: rtl;  
  } 
   
  
  .dr-header {  
    display: flex;  
    justify-content: space-between;  
    align-items: center;  
    margin-bottom: 10px;  
    padding-bottom: 10px;  
    border-bottom: 1px solid #eee;  
  }  
  
  .dr-header h3 {  
    margin: 0;  
    font-size: 12px;  
    font-weight: bold;  
  }  
  
  .calibrating-status {  
    background-color: #ffb300;  
    color: white;  
    padding: 8px;  
    border-radius: 4px;  
    font-size: 14px;  
    text-align: center;  
    margin-bottom: 10px;  
  }  
  
  .dr-button-group {  
    display: grid;  
    grid-template-columns: 1fr 1fr;  
    gap: 8px;  
    margin-bottom: 12px;  
  }  
  
  .dr-button {  
    padding: 8px 0;  
    border: none;  
    border-radius: 4px;  
    font-size: 14px;  
    cursor: pointer;  
    text-align: center;  
  }  
  
  .dr-button-start {  
    background-color: #2196f3;  
    color: white;  
    grid-column: span 2;  
  }  
  
  .dr-button-start.active {  
    background-color: #f44336;  
  }  
  
  .dr-button-reset {  
    background-color: #9e9e9e;  
    color: white;  
  }  
  
  .dr-button-export {  
    background-color: #4caf50;  
    color: white;  
  }  
  
  .dr-button:disabled {  
    opacity: 0.6;  
    cursor: not-allowed;  
  }  
  
  .dr-step-count {  
    margin: 8px 0;  
    font-size: 14px;  
  }  
  
  .dr-stride-control {  
    margin-top: 12px;  
  }  
  
  .dr-stride-label {  
    display: block;  
    margin-bottom: 6px;  
    font-size: 14px;  
  }  
  
  .dr-stride-slider {  
    width: 100%;  
    margin-bottom: 4px;  
  }  
  
  .dr-stride-value {  
    text-align: center;  
    font-size: 14px;  
  }  ```   
   
## \src\components\map\Map.css   
```javascript   
/* Map.css */  
.map-fullscreen {  
  position: fixed;  
  top: 0;  
  left: 0;  
  right: 0;  
  bottom: 0;  
  width: 100%;  
  height: 100vh;  
  z-index: 1;  
}  

.map-container {  
  width: 100%;  
  height: 100%;  
}  

/* استایل مشترک برای همه دکمه‌های دارای آیکون */  
.button-with-icon {  
  display: inline-flex;  
  align-items: center;  
  justify-content: center;  
  gap: 4px;  
}  

.button-with-icon svg {  
  vertical-align: middle;  
  flex-shrink: 0;  
}  

/* نوار ابزار بالای نقشه */  
.map-toolbar {  
  display: flex;  
  align-items: center;  
  padding: 8px 10px;  
  background: #fff;  
  box-shadow: 0 1px 4px rgba(0, 0, 0, 0.1);  
  position: absolute;  
  top: 0;  
  left: 0;  
  right: 0;  
  z-index: 1000;  
}  

.signal-quality-pill {  
  display: flex;  
  align-items: center;  
  gap: 5px;  
  font-size: 0.8rem;  
  padding: 4px 8px;  
  border-radius: 12px;  
  margin: 0 auto;  
}  

.signal-quality-pill.good {  
  background-color: rgba(76, 175, 80, 0.15);  
  color: #1b5e20;  
}  

.signal-quality-pill.medium {  
  background-color: rgba(255, 152, 0, 0.15);  
  color: #e65100;  
}  

.signal-quality-pill.poor {  
  background-color: rgba(244, 67, 54, 0.15);  
  color: #b71c1c;  
}  

.back-button {  
  display: flex;  
  align-items: center;  
  gap: 5px;  
  text-decoration: none;  
  color: #333;  
  font-size: 0.9rem;  
}  

.start-tracking-button {  
  display: flex;  
  align-items: center;  
  gap: 5px;  
  background: #2196f3;  
  color: white;  
  border: none;  
  padding: 6px 10px;  
  border-radius: 4px;  
  font-size: 0.9rem;  
  cursor: pointer;  
}   

.back-button {  
  background-color: white;  
  color: #333;  
  border: none;  
  border-radius: 4px;  
  padding: 4px 8px;  
  font-weight: bold;  
  box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);  
  cursor: pointer;  
  display: inline-flex;  
  align-items: center;  
  justify-content: center;  
  gap: 4px;  
  text-decoration: none;  
  min-width: 90px;  
  height: 28px;  
}  

.back-button svg {  
  vertical-align: middle;  
  margin-top: -1px; /* تنظیم دقیق برای تراز بهتر */  
}  

.back-button:hover {  
  background-color: #f0f0f0;  
}  

.tracking-button {  
  background-color: white;  
  color: #333;  
  border: none;  
  border-radius: 4px;  
  padding: 4px 8px;  
  font-weight: bold;  
  box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);  
  cursor: pointer;  
  display: inline-flex;  
  align-items: center;  
  justify-content: center;  
  gap: 4px;  
  min-width: 90px;  
  height: 28px;  
}  

.tracking-button svg {  
  vertical-align: middle;  
  margin-top: -1px; /* تنظیم دقیق برای تراز بهتر */  
}  

.tracking-button.active {  
  background-color: #0085ff;  
  color: white;  
}  

/* استایل برای دکمه‌های اکشن نیز باید اصلاح شود */  
.action-button {  
  background-color: white;  
  color: #333;  
  border: none;  
  border-radius: 4px;  
  padding: 4px 6px;  
  font-weight: bold;  
  box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);  
  cursor: pointer;  
  display: inline-flex;  
  align-items: center;  
  justify-content: center;  
  gap: 2px;  
}  

.action-button svg {  
  vertical-align: middle;  
  margin-top: -1px; /* تنظیم دقیق برای تراز بهتر */  
}   

/* نوار ابزار پایین نقشه */  
.map-bottom-toolbar {  
  position: absolute;  
  bottom: 25px;  
  left: 50%;  
  transform: translateX(-50%);  
  z-index: 1001;  
  display: flex;  
  justify-content: center;  
  gap: 10px;  
  padding: 8px;  
  background-color: rgba(255, 255, 255, 0.8);  
  border-radius: 8px;  
  box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);  
}   

.error-indicator {  
  background-color: rgba(255, 0, 0, 0.7);  
  color: white;  
  padding: 5px 10px;  
  border-radius: 4px;  
  font-size: 14px;  
}  

.loading-indicator {  
  background-color: rgba(255, 255, 255, 0.8);  
  color: #333;  
  padding: 5px 10px;  
  border-radius: 4px;  
  font-size: 14px;  
}  

.action-button {  
  background-color: white;  
  color: #333;  
  border: none;  
  border-radius: 4px;  
  padding: 4px 6px;  
  font-weight: bold;  
  box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);  
  cursor: pointer;  
  display: flex;  
  align-items: center;  
  gap: 2px;  
}  

.action-button:disabled {  
  opacity: 0.5;  
  cursor: not-allowed;  
}  

.save-button:not(:disabled):hover {  
  background-color: #4CAF50;  
  color: white;  
}  

.share-button:not(:disabled):hover {  
  background-color: #2196F3;  
  color: white;  
}  

.map-clear-button:not(:disabled):hover {  
  background-color: #F44336;  
  color: white;  
}  

/* تغییر از .clear-button به .map-clear-button */  
.map-clear-button {  
  /* استایل‌های موجود برای دکمه پاک کردن در صفحه نقشه */  
  background-color: #f0f0f0;  
  color: #555;  
}  

.map-clear-button:hover {  
  background-color: #e0e0e0;  
}  

.map-clear-button:disabled {  
  opacity: 0.5;  
  cursor: not-allowed;  
}  

/* کنترل‌های نقشه */  
.map-controls-overlay {  
  position: absolute;  
  right: 10px;  
  bottom: 100px; /* افزایش فاصله از پایین */  
  display: flex;  
  flex-direction: column;  
  gap: 10px;  
  z-index: 1000;  
}  

.map-control-button {  
  background-color: white;  
  color: #333;  
  border: none;  
  border-radius: 4px;  
  width: 40px;  
  height: 40px;  
  display: flex;  
  align-items: center;  
  justify-content: center;  
  box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);  
  cursor: pointer;  
}  

.map-control-button.active {  
  background-color: #0085ff;  
  color: white;  
}  

/* پنل اطلاعات موقعیت */  
.location-panel {  
  position: absolute;  
  bottom: 80px; /* فاصله بیشتر از پایین */  
  left: 10px;  
  background-color: rgba(255, 255, 255, 0.9);  
  padding: 8px;  
  border-radius: 4px;  
  box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);  
  z-index: 999; /* کمتر از دکمه‌ها */  
  font-size: 12px;  
  max-width: 180px;  
}  

.coordinates-display {  
  display: flex;  
  flex-direction: column;  
  gap: 3px;  
}  

.coordinates-display span {  
  font-weight: bold;  
}  

/* اطمینان از عدم تداخل با کنترل‌های leaflet */  
.leaflet-control-zoom {  
  margin-top: 60px !important; /* افزایش فاصله از بالا برای جلوگیری از تداخل با نوار ابزار */  
}  

/* برای اپ‌بار در موبایل */  
@media (max-width: 768px) {  
  .map-toolbar {  
    top: 10px;  
    padding: 6px;  
  }  
  
  .map-bottom-toolbar {  
    bottom: 20px;  
    width: 95%;  
    max-width: 400px;  
    padding: 6px;  
    flex-wrap: wrap;  
    justify-content: center;  
  }  
  
  .action-button {  
    font-size: 10px;  
    padding: 6px 8px;  
  }  
  
  .map-controls-overlay {  
    bottom: 90px;  
  }  
  
  .location-panel {  
    bottom: 90px;  
    max-width: 150px;  
    font-size: 10px;  
  }  
  
  .leaflet-control-zoom {  
    margin-top: 70px !important;  
  }  
}  

/* پنل کیفیت سیگنال GPS */  
.gps-quality-panel {  
  position: absolute;  
  bottom: 80px;  
  right: 10px;  
  background-color: rgba(255, 255, 255, 0.9);  
  padding: 8px;  
  border-radius: 4px;  
  box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);  
  z-index: 999;  
  font-size: 12px;  
  width: 150px;  
}  

.quality-header {  
  font-weight: bold;  
  margin-bottom: 4px;  
  text-align: center;  
}  

.quality-meter {  
  height: 6px;  
  background-color: #f0f0f0;  
  border-radius: 3px;  
  overflow: hidden;  
  margin-bottom: 4px;  
}  

.quality-bar {  
  height: 100%;  
  transition: width 0.5s ease;  
}  

.quality-bar.good {  
  background-color: #4CAF50;  
}  

.quality-bar.medium {  
  background-color: #FFC107;  
}  

.quality-bar.poor {  
  background-color: #F44336;  
}  

.quality-text {  
  font-size: 10px;  
  text-align: center;  
}  

.quality-warning {  
  color: #F44336;  
  display: flex;  
  align-items: center;  
  justify-content: center;  
  gap: 4px;  
  margin-top: 4px;  
}  

/* تغییر موقعیت در موبایل */  
@media (max-width: 768px) {  
  .gps-quality-panel {  
    bottom: 90px;  
    width: 120px;  
    font-size: 10px;  
  }  
}  

/* پنل کیفیت سیگنال GPS */  
.gps-quality-panel {  
  position: absolute;  
  bottom: 80px;  
  right: 10px;  
  background-color: rgba(255, 255, 255, 0.9);  
  padding: 8px;  
  border-radius: 4px;  
  box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);  
  z-index: 999;  
  font-size: 12px;  
  width: 150px;  
  direction: rtl;  
}  

.quality-header {  
  font-weight: bold;  
  margin-bottom: 4px;  
  text-align: center;  
}  

.quality-meter {  
  height: 6px;  
  background-color: #f0f0f0;  
  border-radius: 3px;  
  overflow: hidden;  
  margin-bottom: 4px;  
}  

.quality-bar {  
  height: 100%;  
  transition: width 0.5s ease;  
}  

.quality-bar.good {  
  background-color: #4CAF50;  
}  

.quality-bar.medium {  
  background-color: #FFC107;  
}  

.quality-bar.poor {  
  background-color: #F44336;  
}  

.quality-text {  
  font-size: 11px;  
  text-align: center;  
}  

.quality-good {  
  color: #4CAF50;  
}  

.quality-medium {  
  color: #FFC107;  
}  

.quality-poor {  
  color: #F44336;  
}  

.quality-warning {  
  color: #F44336;  
  display: flex;  
  align-items: center;  
  justify-content: center;  
  gap: 4px;  
  margin-top: 4px;  
  font-size: 10px;  
}  

.error-indicator {  
  display: flex;  
  align-items: center;  
  background-color: rgba(244, 67, 54, 0.1);  
  color: #F44336;  
  padding: 4px 8px;  
  border-radius: 4px;  
  margin-right: 8px;  
  font-size: 12px;  
}  

.error-indicator svg {  
  margin-left: 4px;  
}  

/* تغییر موقعیت در موبایل */  
@media (max-width: 768px) {  
  .gps-quality-panel {  
    bottom: 90px;  
    width: 120px;  
    font-size: 10px;  
  }  
}  

/* اضافه کردن به فایل CSS موجود برای صفحه نقشه */  

.alerts-container {  
  position: fixed;  
  bottom: 80px; /* بالاتر از نوار ابزار پایین */  
  left: 50%;  
  transform: translateX(-50%);  
  width: 90%;  
  max-width: 400px;  
  z-index: 1000;  
  display: flex;  
  flex-direction: column;  
  gap: 8px;  
  pointer-events: none; /* اجازه کلیک روی نقشه زیرین */  
}  

.alert-toast {  
  display: flex;  
  align-items: center;  
  padding: 12px 16px;  
  border-radius: 10px;  
  background-color: rgba(255, 255, 255, 0.95);  
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);  
  animation: slideIn 0.3s ease forwards, fadeOut 0.3s ease 5s forwards;  
  pointer-events: auto; /* این المان قابل کلیک است */  
  backdrop-filter: blur(10px);  
  border: 1px solid rgba(0, 0, 0, 0.05);  
  font-size: 0.9rem;  
  max-width: 100%;  
}  

.error-alert {  
  border-right: 4px solid #e53935;  
}  

.warning-alert {  
  border-right: 4px solid #ffb300;  
}  

.info-alert {  
  border-right: 4px solid #039be5;  
}  

.success-alert {  
  border-right: 4px solid #43a047;  
}  

.alert-icon {  
  margin-left: 12px;  
  line-height: 0;  
  flex-shrink: 0;  
}  

.error-alert .alert-icon {  
  color: #e53935;  
}  

.warning-alert .alert-icon {  
  color: #ffb300;  
}  

.info-alert .alert-icon {  
  color: #039be5;  
}  

.success-alert .alert-icon {  
  color: #43a047;  
}  

.alert-icon.spinning svg {  
  animation: spin 1.5s linear infinite;  
}  

.alert-content {  
  flex: 1;  
  min-width: 0;  
}  

.alert-title {  
  font-weight: 600;  
  margin-bottom: 2px;  
  color: #333;  
}  

.alert-message {  
  color: #555;  
  overflow: hidden;  
  text-overflow: ellipsis;  
}  

.alert-details {  
  display: flex;  
  flex-wrap: wrap;  
  gap: 8px;  
  margin-top: 4px;  
  font-size: 0.8rem;  
}  

.alert-details span {  
  background-color: rgba(0, 0, 0, 0.05);  
  padding: 2px 6px;  
  border-radius: 4px;  
  color: #666;  
}  

.alert-close {  
  background: none;  
  border: none;  
  padding: 4px;  
  color: #aaa;  
  border-radius: 50%;  
  cursor: pointer;  
  margin-right: 8px;  
  line-height: 0;  
  transition: all 0.2s;  
  flex-shrink: 0;  
}  

.alert-close:hover {  
  background-color: rgba(0, 0, 0, 0.05);  
  color: #555;  
}  

@keyframes slideIn {  
  from {  
    opacity: 0;  
    transform: translateY(20px);  
  }  
  to {  
    opacity: 1;  
    transform: translateY(0);  
  }  
}  

@keyframes fadeOut {  
  from {  
    opacity: 1;  
  }  
  to {  
    opacity: 0;  
    transform: translateY(-20px);  
  }  
}  

@keyframes spin {  
  0% {  
    transform: rotate(0deg);  
  }  
  100% {  
    transform: rotate(360deg);  
  }  
}  

/* برای دستگاه‌های موبایل در حالت افقی */  
@media screen and (max-height: 500px) {  
  .alerts-container {  
    bottom: auto;  
    top: 70px;  
  }  
}  ```   
   
## \src\components\settings\SettingsPage.jsx   
```javascript   
// src/components/settings/SettingsPage.jsx  
import React, { useState, useEffect } from 'react';  
import { Link } from 'react-router-dom';  
import { LogStorageService } from '../../services/LogStorageService';  
import './Settings.css';  

const SettingsPage = () => {  
  const [logCounts, setLogCounts] = useState({ gpsLogs: 0, trackLogs: 0 });  
  const [storageSize, setStorageSize] = useState({ gpsLogsSize: 0, trackLogsSize: 0, totalSize: 0 });  
  const [isLoading, setIsLoading] = useState(true);  
  const [isExporting, setIsExporting] = useState(false);  
  const [message, setMessage] = useState('');  
  
  // دریافت آمار لاگ‌ها  
  useEffect(() => {  
    async function fetchLogStats() {  
      try {  
        setIsLoading(true);  
        const counts = await LogStorageService.getLogCounts();  
        const size = await LogStorageService.estimateStorageSize();  
        
        setLogCounts(counts);  
        setStorageSize(size);  
        setIsLoading(false);  
      } catch (error) {  
        console.error('خطا در دریافت آمار لاگ‌ها:', error);  
        setMessage('خطا در دریافت آمار لاگ‌ها');  
        setIsLoading(false);  
      }  
    }  
    
    fetchLogStats();  
  }, []);  
  
  // تبدیل ب```   
   
## \src\hooks\useGPS.js   
```javascript   
import { useState, useEffect, useRef } from 'react';  
import { useGPSStore } from '../store/gpsStore';  

// Hook برای کار با GPS و دریافت موقعیت  
const useGPS = (options = {}) => {  
  const {   
    enableHighAccuracy = true,   
    timeout = 5000,   
    maximumAge = 0,  
    watchPosition = true  
  } = options;  
  
  const [position, setPosition] = useState(null);  
  const [error, setError] = useState(null);  
  const [loading, setLoading] = useState(true);  
  const watchIdRef = useRef(null);  
  
  const { updateCurrentLocation, addLocationToHistory } = useGPSStore();  
  
  // تبدیل داده خام GPS به فرمت مناسب  
  const processPosition = (pos) => {  
    const { latitude, longitude, accuracy, altitude, heading, speed } = pos.coords;  
    const timestamp = pos.timestamp;  
    
    const formattedPosition = {  
      coords: {  
        lat: latitude,  
        lng: longitude,  
        accuracy,  
        altitude,  
        heading,  
        speed  
      },  
      timestamp  
    };  
    
    setPosition(formattedPosition);  
    setLoading(false);  
    
    // به‌روزرسانی store  
    updateCurrentLocation(formattedPosition);  
    addLocationToHistory(formattedPosition);  
    
    return formattedPosition;  
  };  
  
  // مدیریت خطاها  
  const handleError = (err) => {  
    setError(err);  
    setLoading(false);  
    console.error('GPS Error:', err.message);  
  };  

  // دریافت موقعیت فعلی  
  const getCurrentPosition = () => {  
    setLoading(true);  
    
    if (!navigator.geolocation) {  
      setError(new Error('Geolocation is not supported by this browser'));  
      setLoading(false);  
      return Promise.reject('Geolocation not supported');  
    }  
    
    return new Promise((resolve, reject) => {  
      navigator.geolocation.getCurrentPosition(  
        (pos) => {  
          const formattedPos = processPosition(pos);  
          resolve(formattedPos);  
        },  
        (err) => {  
          handleError(err);  
          reject(err);  
        },  
        { enableHighAccuracy, timeout, maximumAge }  
      );  
    });  
  };  
  
  // شروع tracking موقعیت  
  const startWatching = () => {  
    if (!navigator.geolocation) {  
      setError(new Error('Geolocation is not supported by this browser'));  
      setLoading(false);  
      return;  
    }  
    
    watchIdRef.current = navigator.geolocation.watchPosition(  
      processPosition,  
      handleError,  
      { enableHighAccuracy, timeout, maximumAge }  
    );  
    
    return watchIdRef.current;  
  };  
  
  // توقف tracking موقعیت  
  const stopWatching = () => {  
    if (watchIdRef.current && navigator.geolocation) {  
      navigator.geolocation.clearWatch(watchIdRef.current);  
      watchIdRef.current = null;  
    }  
  };  
  
  useEffect(() => {  
    if (watchPosition) {  
      startWatching();  
    } else {  
      getCurrentPosition();  
    }  
    
    return () => {  
      stopWatching();  
    };  
  }, []);  
  
  return {  
    position,  
    error,  
    loading,  
    getCurrentPosition,  
    startWatching,  
    stopWatching  
  };  
};  

export default useGPS;  ```   
   
## \src\hooks\useIMUSensors.js   
```javascript   
import { useState, useEffect } from 'react';  
import advancedDeadReckoningService from '../services/AdvancedDeadReckoningService';  

const useIMUSensors = () => {  
  const [isSupported, setIsSupported] = useState(false);  
  const [hasPermission, setHasPermission] = useState(false);  
  const [acceleration, setAcceleration] = useState(null);  
  const [rotationRate, setRotationRate] = useState(null);  
  const [orientation, setOrientation] = useState(null);  
  
  // بررسی پشتیبانی سنسورها  
  useEffect(() => {  
    const checkSupport = () => {  
      const hasMotion = window.DeviceMotionEvent !== undefined;  
      const hasOrientation = window.DeviceOrientationEvent !== undefined;  
      const supported = hasMotion && hasOrientation;  
      setIsSupported(supported);  
      
      console.log('Device motion support:', hasMotion);  
      console.log('Device orientation support:', hasOrientation);  
      
      // در برخی مرورگرها مانند کروم دسکتاپ، نیازی به مجوز نیست  
      if (supported &&   
          !(typeof DeviceMotionEvent.requestPermission === 'function') &&   
          !(typeof DeviceOrientationEvent.requestPermission === 'function')) {  
        setHasPermission(true);  
      }  
      
      return supported;  
    };  
    
    if (checkSupport()) {  
      console.log("IMU sensors are supported by this device");  
    } else {  
      console.warn("IMU sensors are NOT supported by this device");  
    }  
  }, []);  
  
  // افزودن لیستنرهای سنسور  
  useEffect(() => {  
    if (!isSupported || !hasPermission) {  
      return;  
    }  
    
    console.log("Setting up sensor listeners");  
    
    // لیستنر شتاب‌سنج  
    const handleMotion = (event) => {  
      if (!event) return;  
      
      // تشخیص نوع داده شتاب‌سنج  
      if (event.acceleration && event.acceleration.x !== null) {  
        // شتاب خالص (بدون جاذبه)  
        const accel = {  
          x: event.acceleration.x || 0,  
          y: event.acceleration.y || 0,  
          z: event.acceleration.z || 0,  
          timestamp: event.timeStamp || Date.now(),  
          includesGravity: false  
        };  
        setAcceleration(accel);  
        
        // ارسال داده به سرویس در صورت فعال بودن  
        if (advancedDeadReckoningService.isActive) {  
          advancedDeadReckoningService.processAccelerometerData(accel, accel.timestamp);  
        }  
      } else if (event.accelerationIncludingGravity && event.accelerationIncludingGravity.x !== null) {  
        // شتاب با جاذبه  
        const accel = {  
          x: event.accelerationIncludingGravity.x || 0,  
          y: event.accelerationIncludingGravity.y || 0,  
          z: event.accelerationIncludingGravity.z || 0,  
          timestamp: event.timeStamp || Date.now(),  
          includesGravity: true  
        };  
        setAcceleration(accel);  
        
        // ارسال داده به سرویس در صورت فعال بودن  
        if (advancedDeadReckoningService.isActive) {  
          advancedDeadReckoningService.processAccelerometerData(accel, accel.timestamp);  
        }  
      }  
      
      // داده‌های ژیروسکوپ  
      if (event.rotationRate && event.rotationRate.alpha !== null) {  
        const gyro = {  
          alpha: event.rotationRate.alpha || 0,  
          beta: event.rotationRate.beta || 0,  
          gamma: event.rotationRate.gamma || 0,  
          timestamp: event.timeStamp || Date.now()  
        };  
        setRotationRate(gyro);  
        
        // ارسال داده به سرویس در صورت فعال بودن  
        if (advancedDeadReckoningService.isActive) {  
          advancedDeadReckoningService.processGyroscopeData(gyro, gyro.timestamp);  
        }  
      }  
    };  
    
    // لیستنر جهت‌یابی  
    const handleOrientation = (event) => {  
      if (!event || event.alpha === null) return;  
      
      const orient = {  
        alpha: event.alpha || 0, // جهت (0-360 درجه)  
        beta: event.beta || 0,   // شیب جلو/عقب (-180 تا 180 درجه)  
        gamma: event.gamma || 0, // شیب چپ/راست (-90 تا 90 درجه)  
        absolute: event.absolute || false,  
        timestamp: event.timeStamp || Date.now()  
      };  
      setOrientation(orient);  
      
      // ارسال داده به سرویس در صورت فعال بودن  
      if (advancedDeadReckoningService.isActive) {  
        advancedDeadReckoningService.processOrientationData(orient, orient.timestamp);  
      }  
    };  
    
    // تنظیم نرخ نمونه‌برداری (در صورت امکان)  
    if (typeof DeviceMotionEvent.requestPermission === 'function') {  
      // در iOS جدید  
      window.addEventListener('devicemotion', handleMotion, { frequency: 60 });  
      window.addEventListener('deviceorientation', handleOrientation, { frequency: 60 });  
    } else {  
      // سایر دستگاه‌ها  
      window.addEventListener('devicemotion', handleMotion);  
      window.addEventListener('deviceorientation', handleOrientation);  
    }  
    
    console.log("Sensor listeners added");  
    
    // حذف لیستنرها در هنگام unmount  
    return () => {  
      console.log("Removing sensor listeners");  
      window.removeEventListener('devicemotion', handleMotion);  
      window.removeEventListener('deviceorientation', handleOrientation);  
    };  
  }, [isSupported, hasPermission, advancedDeadReckoningService.isActive]);  
  
  // درخواست مجوز دسترسی به سنسورها (برای iOS 13+)  
  const requestPermission = async () => {  
    if (!isSupported) {  
      console.warn("Sensors not supported, cannot request permission");  
      return false;  
    }  
    
    try {  
      // برای iOS 13+  
      if (typeof DeviceMotionEvent.requestPermission === 'function' &&  
          typeof DeviceOrientationEvent.requestPermission === 'function') {  
        
        console.log('Requesting permissions for iOS...');  
        
        const motionPermission = await DeviceMotionEvent.requestPermission();  
        const orientationPermission = await DeviceOrientationEvent.requestPermission();  
        
        const granted = motionPermission === 'granted' && orientationPermission === 'granted';  
        setHasPermission(granted);  
        console.log(`Permission ${granted ? 'granted' : 'denied'}`);  
        return granted;  
      } else {  
        // برای سایر دستگاه‌ها، فرض می‌کنیم مجوز داریم  
        console.log('No permission request needed for this device');  
        setHasPermission(true);  
        return true;  
      }  
    } catch (error) {  
      console.error('Error requesting sensor permissions:', error);  
      return false;  
    }  
  };  
  
  // بررسی وضعیت مجوزها  
  const checkPermissions = async () => {  
    if (!isSupported) return false;  
    
    // در iOS نیاز به درخواست صریح است  
    if (typeof DeviceMotionEvent.requestPermission === 'function') {  
      return hasPermission;  
    }  
    
    // در سایر دستگاه‌ها، فرض می‌کنیم مجوز داریم  
    setHasPermission(true);  
    return true;  
  };  
  
  return {  
    acceleration,  
    rotationRate,  
    orientation,  
    isSupported,  
    hasPermission,  
    requestPermission,  
    checkPermissions  
  };  
};  

export default useIMUSensors;  ```   
   
## \src\pages\HomePage.jsx   
```javascript   
import React from 'react';  
import { Link } from 'react-router-dom';  

export const HomePage = () => {  
  return (  
    <div className="home-page">  
      <section className="hero">  
        <h1>به اپلیکیشن مسیر طلایی خوش آمدید</h1>  
        <p>ردیابی دقیق موقعیت و ناوبری حتی در شرایط سخت</p>  
        
        <div className="hero-buttons">  
          <Link to="/map" className="btn btn-primary">  
            شروع ناوبری  
          </Link>  
          <Link to="/qr-scan" className="btn btn-secondary">  
            اسکن QR کد  
          </Link>  
        </div>  
      </section>  
      
      <section className="features">  
        <h2>امکانات اصلی</h2>  
        
        <div className="feature-cards">  
          <div className="feature-card">  
            <div className="feature-icon">🛰️</div>  
            <h3>ردیابی دقیق GPS</h3>  
            <p>دریافت موقعیت با دقت بالا و نمایش روی نقشه</p>  
          </div>  
          
          <div className="feature-card">  
            <div className="feature-icon">📱</div>  
            <h3>Dead Reckoning</h3>  
            <p>ردیابی حرکت حتی در شرایط بدون GPS با استفاده از سنسورهای دستگاه</p>  
          </div>  
          
          <div className="feature-card">  
            <div className="feature-icon">📷</div>  
            <h3>اسکن QR کد</h3>  
            <p>دریافت موقعیت و اطلاعات از طریق اسکن QR کد</p>  
          </div>  
          
          <div className="feature-card">  
            <div className="feature-icon">🔄</div>  
            <h3>کارکرد آفلاین</h3>  
            <p>قابلیت استفاده از اپلیکیشن بدون نیاز به اینترنت</p>  
          </div>  
        </div>  
      </section>  
      
      <section className="how-to-use">  
        <h2>نحوه استفاده</h2>  
        
        <div className="steps">  
          <div className="step">  
            <div className="step-number">1</div>  
            <h3>دسترسی به موقعیت</h3>  
            <p>به اپلیکیشن اجازه دسترسی به موقعیت دستگاه خود را بدهید</p>  
          </div>  
          
          <div className="step">  
            <div className="step-number">2</div>  
            <h3>انتخاب حالت ناوبری</h3>  
            <p>از بین گزینه‌های GPS، QR کد یا Dead Reckoning انتخاب کنید</p>  
          </div>  
          
          <div className="step">  
            <div className="step-number">3</div>  
            <h3>شروع ردیابی</h3>  
            <p>دکمه شروع ردیابی را فشار دهید و مسیر خود را ثبت کنید</p>  
          </div>  
        </div>  
      </section>  
    </div>  
  );  
};  

// سطر زیر اضافه نشود - به جای آن از { HomePage } در import استفاده شود  
// export default HomePage;  ```   
   
## \src\pages\MapPage.jsx   
```javascript   
// src/pages/MapPage.jsx  
import React, { useState, useEffect, useCallback } from 'react';  
import { Link } from 'react-router-dom';
import MapView from '../components/map/MapView';
import { useGPSNoiseDetection } from '../utils/useGPSNoiseDetection';
import { isValidGPSReading } from '../utils/gpsFilter';
import { LogStorageService } from '../services/LogStorageService';

export const MapPage = () => {
  const [currentLocation, setCurrentLocation] = useState(null);
  const [locationHistory, setLocationHistory] = useState([]);
  const [savedLocations, setSavedLocations] = useState([]);
  const [isTracking, setIsTracking] = useState(false);
  const [error, setError] = useState(null);
  const [loading, setLoading] = useState(true);
  const [trackStartTime, setTrackStartTime] = useState(null);

  // استفاده از هوک تشخیص نویز  
  const {
    isJamming,
    isAccuracyLow,
    isSpeedUnrealistic,
    isPositionJumping,
    anomalyScore,
    noiseLevel
  } = useGPSNoiseDetection(locationHistory, currentLocation);

  // دریافت موقعیت فعلی  
  const getCurrentPosition = useCallback(() => {
    setLoading(true);
    setError(null);

    if (!navigator.geolocation) {
      setError('مرورگر شما از Geolocation پشتیبانی نمی‌کند');
      setLoading(false);
      return;
    }

    navigator.geolocation.getCurrentPosition(
      (position) => {
        console.log('موقعیت فعلی دریافت شد:', position);
        const { latitude, longitude, accuracy, altitude, heading, speed } = position.coords;
        const newLocation = {
          coords: {
            lat: latitude,
            lng: longitude,
            accuracy,
            altitude,
            heading,
            speed
          },
          timestamp: position.timestamp,
          id: Date.now()
        };

        // ذخیره لاگ در دیتابیس لوکال  
        LogStorageService.saveGPSLog(newLocation, false);

        setCurrentLocation(newLocation);
        setLoading(false);
      },
      (error) => {
        console.error('خطا در دریافت موقعیت:', error);
        let errorMessage = 'خطا در دریافت موقعیت';

        switch (error.code) {
          case error.PERMISSION_DENIED:
            errorMessage = 'دسترسی به موقعیت توسط کاربر رد شده است';
            break;
          case error.POSITION_UNAVAILABLE:
            errorMessage = 'اطلاعات موقعیت در دسترس نیست';
            break;
          case error.TIMEOUT:
            errorMessage = 'زمان درخواست موقعیت به پایان رسید';
            break;
          case error.UNKNOWN_ERROR:
            errorMessage = 'خطای ناشناخته در دریافت موقعیت';
            break;
        }

        setError(errorMessage);
        setLoading(false);
      },
      {
        enableHighAccuracy: true,
        timeout: 10000,
        maximumAge: 0
      }
    );
  }, []);

  // شروع ردیابی مداوم  
  const startTracking = useCallback(() => {
    setIsTracking(true);
    setTrackStartTime(Date.now());

    if (!navigator.geolocation) {
      setError('مرورگر شما از Geolocation پشتیبانی نمی‌کند');
      return;
    }

    // دریافت موقعیت اولیه  
    getCurrentPosition();

    // شروع ردیابی مداوم  
    const watchId = navigator.geolocation.watchPosition(
      (position) => {
        console.log('دریافت موقعیت جدید از watchPosition:', position);
        const { latitude, longitude, accuracy, altitude, heading, speed } = position.coords;
        const newLocation = {
          coords: {
            lat: latitude,
            lng: longitude,
            accuracy,
            altitude,
            heading,
            speed
          },
          timestamp: position.timestamp,
          id: Date.now()
        };

        setCurrentLocation(prevLocation => {
          // تشخیص نویز  
          const isNoisy = prevLocation && !isValidGPSReading(newLocation, prevLocation);

          // ذخیره لاگ در دیتابیس لوکال  
          LogStorageService.saveGPSLog(newLocation, isNoisy);

          // فیلتر کردن داده‌های نویزی (اختیاری)  
          if (!isNoisy) {
            // اضافه کردن به تاریخچه فقط اگر معتبر باشد  
            setLocationHistory(prevHistory => {
              const newHistory = [...prevHistory, newLocation];
              console.log('نقطه جدید به تاریخچه اضافه شد. تعداد نقاط:', newHistory.length);
              return newHistory;
            });
          } else {
            console.log('داده GPS نویزی فیلتر شد و به تاریخچه اضافه نشد');
          }

          // همیشه موقعیت فعلی را به‌روز می‌کنیم، حتی اگر به تاریخچه اضافه نشود  
          return newLocation;
        });

        setError(null);
      },
      (error) => {
        console.error('خطا در ردیابی موقعیت:', error);
        let errorMessage = 'خطا در ردیابی موقعیت';

        switch (error.code) {
          case error.PERMISSION_DENIED:
            errorMessage = 'دسترسی به موقعیت توسط کاربر رد شده است';
            break;
          case error.POSITION_UNAVAILABLE:
            errorMessage = 'اطلاعات موقعیت در دسترس نیست';
            break;
          case error.TIMEOUT:
            errorMessage = 'زمان درخواست موقعیت به پایان رسید';
            break;
          case error.UNKNOWN_ERROR:
            errorMessage = 'خطای ناشناخته در دریافت موقعیت';
            break;
        }

        setError(errorMessage);
      },
      {
        enableHighAccuracy: true,
        timeout: 10000,
        maximumAge: 0
      }
    );

    // ذخیره ID مربوط به watchPosition برای پاکسازی بعدی  
    window.geolocationWatchId = watchId;
  }, [getCurrentPosition]);

  // توقف ردیابی  
  const stopTracking = useCallback(() => {
    setIsTracking(false);

    if (window.geolocationWatchId !== undefined && navigator.geolocation) {
      navigator.geolocation.clearWatch(window.geolocationWatchId);
      window.geolocationWatchId = undefined;
      console.log('ردیابی GPS متوقف شد');

      // ذخیره تاریخچه مسیر در پایان ردیابی  
      if (trackStartTime && locationHistory.length > 0) {
        const endTime = Date.now();
        const trackName = prompt('نام این مسیر را وارد کنید:', `مسیر ${new Date().toLocaleDateString('fa-IR')}`);

        LogStorageService.saveTrackLog(
          locationHistory,
          trackStartTime,
          endTime,
          {
            name: trackName || `مسیر ${new Date().toLocaleDateString('fa-IR')}`,
            noiseScore: anomalyScore,
            quality: noiseLevel,
            length: locationHistory.length
          }
        );

        console.log('مسیر ذخیره شد');
      }
    }
  }, [locationHistory, trackStartTime, anomalyScore, noiseLevel]);

  // تغییر وضعیت ردیابی  
  const toggleTracking = useCallback(() => {
    if (isTracking) {
      stopTracking();
    } else {
      startTracking();
    }
  }, [isTracking, stopTracking, startTracking]);

  // ذخیره موقعیت فعلی  
  const saveCurrentLocation = useCallback(() => {
    if (currentLocation) {
      const locationName = prompt('نام این مکان را وارد کنید:', 'مکان جدید');

      if (locationName) {
        const savedLocation = {
          ...currentLocation,
          name: locationName,
          id: Date.now()
        };

        setSavedLocations(prevLocations => [...prevLocations, savedLocation]);
        alert(`موقعیت "${locationName}" با موفقیت ذخیره شد.`);
      }
    } else {
      alert('موقعیتی برای ذخیره وجود ندارد.');
    }
  }, [currentLocation]);

  // اشتراک‌گذاری موقعیت فعلی  
  const shareCurrentLocation = useCallback(() => {
    if (!currentLocation) {
      alert('موقعیتی برای اشتراک‌گذاری وجود ندارد.');
      return;
    }

    const { lat, lng } = currentLocation.coords;
    const googleMapsUrl = `https://maps.google.com/maps?q=${lat},${lng}`;

    if (navigator.share) {
      navigator.share({
        title: 'موقعیت من',
        text: `موقعیت من: ${lat}, ${lng}`,
        url: googleMapsUrl
      })
        .then(() => console.log('موقعیت با موفقیت به اشتراک گذاشته شد'))
        .catch((error) => console.error('خطا در اشتراک‌گذاری:', error));
    } else {
      // کپی لینک در کلیپ‌بورد  
      const textarea = document.createElement('textarea');
      textarea.value = googleMapsUrl;
      document.body.appendChild(textarea);
      textarea.select();
      document.execCommand('copy');
      document.body.removeChild(textarea);

      alert(`لینک موقعیت در کلیپ‌بورد کپی شد: ${googleMapsUrl}`);
    }
  }, [currentLocation]);

  // پاک کردن تاریخچه مسیر  
  const clearTrackHistory = useCallback(() => {
    if (locationHistory.length > 0) {
      if (window.confirm('آیا مطمئن هستید که می‌خواهید تاریخچه مسیر را پاک کنید؟')) {
        setLocationHistory([]);
        console.log('تاریخچه مسیر پاک شد');
      }
    } else {
      alert('تاریخچه مسیری برای پاک کردن وجود ندارد.');
    }
  }, [locationHistory.length]);

  // دریافت موقعیت اولیه هنگام بارگذاری صفحه  
  useEffect(() => {
    console.log('MapPage mounted - دریافت موقعیت اولیه');
    getCurrentPosition();

    return () => {
      // پاکسازی  
      if (window.geolocationWatchId !== undefined && navigator.geolocation) {
        navigator.geolocation.clearWatch(window.geolocationWatchId);
        console.log('ردیابی GPS پاکسازی شد (unmount)');
      }
    };
  }, [getCurrentPosition]);

  // نمایش اطلاعات نویز GPS در کنسول برای دیباگ  
  useEffect(() => {
    if (isJamming) {
      console.log('هشدار: احتمال اختلال در سیگنال GPS', {
        score: anomalyScore,
        isAccuracyLow,
        isSpeedUnrealistic,
        isPositionJumping
      });
    }
  }, [isJamming, anomalyScore, isAccuracyLow, isSpeedUnrealistic, isPositionJumping]);

  return (
    <div className="map-fullpage">
      {/* نوار ابزار بالای نقشه - روی نقشه قرار می‌گیرد */}
      <div className="map-toolbar">
        <Link to="/" className="back-button">
          <svg viewBox="0 0 24 24" width="16" height="16" stroke="currentColor" strokeWidth="2" fill="none">
            <path d="M15 18l-6-6 6-6" />
          </svg>
          <span>بازگشت</span>
        </Link>

        {/* نشانگر کیفیت سیگنال در نوار بالا */}
        <div className={`signal-quality-pill ${anomalyScore < 20 ? 'good' :
            anomalyScore < 50 ? 'medium' : 'poor'
          }`}>
          <svg viewBox="0 0 24 24" width="14" height="14" fill="none" stroke="currentColor" strokeWidth="2">
            <path d="M2 12 L12 2 L22 12"></path>
            <path d="M5 15 L12 8 L19 15"></path>
            <path d="M8 18 L12 14 L16 18"></path>
          </svg>
          <span>GPS: {
            noiseLevel === 'کم' ? 'خوب' :
              noiseLevel === 'متوسط' ? 'متوسط' : 'ضعیف'
          }</span>
        </div>

        <button
          className={`tracking-button ${isTracking ? 'active' : ''}`}
          onClick={toggleTracking}
        >
          <svg viewBox="0 0 24 24" width="16" height="16" stroke="currentColor" strokeWidth="2" fill="none">
            {isTracking ? (
              <path d="M10 9v6l5-3-5-3z M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
            ) : (
              <path d="M12 8v4l3 3-1.5 1.5L9 12V8h3z M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
            )}
          </svg>
          <span>{isTracking ? 'توقف ردیابی' : 'شروع ردیابی'}</span>
        </button>
      </div>

      {/* نقشه اصلی */}
      <MapView
        currentLocation={currentLocation}
        locationHistory={locationHistory}
        savedLocations={savedLocations}
        followUser={true}
        initialZoom={15}
      />

      {/* نوار ابزار پایین نقشه */}
      <div className="map-bottom-toolbar">
        <button
          className="action-button save-button"
          onClick={saveCurrentLocation}
          disabled={!currentLocation || isJamming}
        >
          <svg viewBox="0 0 24 24" width="16" height="16" fill="none" stroke="currentColor" strokeWidth="2">
            <path d="M19 21H5a2 2 0 01-2-2V5a2 2 0 012-2h11l5 5v11a2 2 0 01-2 2z"></path>
            <polyline points="17 21 17 13 7 13 7 21"></polyline>
            <polyline points="7 3 7 8 15 8"></polyline>
          </svg>
          <span>ذخیره موقعیت</span>
        </button>

        <button
          className="action-button share-button"
          onClick={shareCurrentLocation}
          disabled={!currentLocation}
        >
          <svg viewBox="0 0 24 24" width="16" height="16" fill="none" stroke="currentColor" strokeWidth="2">
            <circle cx="18" cy="5" r="3"></circle>
            <circle cx="6" cy="12" r="3"></circle>
            <circle cx="18" cy="19" r="3"></circle>
            <line x1="8.59" y1="13.51" x2="15.42" y2="17.49"></line>
            <line x1="15.41" y1="6.51" x2="8.59" y2="10.49"></line>
          </svg>
          <span>اشتراک‌گذاری</span>
        </button>

        <button
          className="action-button map-clear-button" // تغییر از clear-button به map-clear-button  
          onClick={clearTrackHistory}
          disabled={locationHistory.length === 0}
        >
          <svg viewBox="0 0 24 24" width="16" height="16" fill="none" stroke="currentColor" strokeWidth="2">
            <polyline points="3 6 5 6 21 6"></polyline>
            <path d="M19 6v14a2 2 0 01-2 2H7a2 2 0 01-2-2V6m3 0V4a2 2 0 012-2h4a2 2 0 012 2v2"></path>
          </svg>
          <span>پاک کردن مسیر</span>
        </button>

        {/*        <Link to="/settings" className="action-button settings-button">
          <svg viewBox="0 0 24 24" width="16" height="16" fill="none" stroke="currentColor" strokeWidth="2">  
            <circle cx="12" cy="12" r="3"></circle>  
            <path d="M19.4 15a1.65 1.65 0 00.33 1.82l.06.06a2 2 0 010 2.83 2 2 0 01-2.83 0l-.06-.06a1.65 1.65 0 00-1.82-.33 1.65 1.65 0 00-1 1.51V21a2 2 0 01-2 2 2 2 0 01-2-2v-.09A1.65 1.65 0 009 19.4a1.65 1.65 0 00-1.82.33l-.06.06a2 2 0 01-2.83 0 2 2 0 010-2.83l.06-.06a1.65 1.65 0 00.33-1.82 1.65 1.65 0 00-1.51-1H3a2 2 0 01-2-2 2 2 0 012-2h.09A1.65 1.65 0 004.6 9a1.65 1.65 0 00-.33-1.82l-.06-.06a2 2 0 010-2.83 2 2 0 012.83 0l.06.06a1.65 1.65 0 001.82.33H9a1.65 1.65 0 001-1.51V3a2 2 0 012-2 2 2 0 012 2v.09a1.65 1.65 0 001 1.51 1.65 1.65 0 001.82-.33l.06-.06a2 2 0 012.83 0 2 2 0 010 2.83l-.06.06a1.65 1.65 0 00-.33 1.82V9a1.65 1.65 0 001.51 1H21a2 2 0 012 2 2 2 0 01-2 2h-.09a1.65 1.65 0 00-1.51 1z"></path>  
          </svg>  
          <span>تنظیمات</span>  
        </Link>  */}
      </div>
      {/* سیستم نمایش هشدارها و خطاها */}
      <div className="alerts-container">
        {isJamming && (
          <div className="alert-toast warning-alert">
            <div className="alert-icon">
              <svg viewBox="0 0 24 24" width="20" height="20" fill="none" stroke="currentColor" strokeWidth="2">
                <path d="M10.29 3.86L1.82 18a2 2 0 001.71 3h16.94a2 2 0 001.71-3L13.71 3.86a2 2 0 00-3.42 0z"></path>
                <line x1="12" y1="9" x2="12" y2="13"></line>
                <line x1="12" y1="17" x2="12.01" y2="17"></line>
              </svg>
            </div>
            <div className="alert-content">
              <div className="alert-title">احتمال اختلال GPS</div>
              <div className="alert-details">
                {isPositionJumping && <span>پرش موقعیت</span>}
                {isSpeedUnrealistic && <span>سرعت غیرعادی</span>}
                {isAccuracyLow && <span>دقت پایین</span>}
              </div>
            </div>
            <button className="alert-close" onClick={() => {/* اینجا می‌توانید اختیاری هشدار را بی‌صدا کنید */ }}>
              <svg viewBox="0 0 24 24" width="16" height="16" fill="none" stroke="currentColor" strokeWidth="2">
                <line x1="18" y1="6" x2="6" y2="18"></line>
                <line x1="6" y1="6" x2="18" y2="18"></line>
              </svg>
            </button>
          </div>
        )}

        {error && (
          <div className="alert-toast error-alert">
            <div className="alert-icon">
              <svg viewBox="0 0 24 24" width="20" height="20" fill="none" stroke="currentColor" strokeWidth="2">
                <circle cx="12" cy="12" r="10"></circle>
                <line x1="15" y1="9" x2="9" y2="15"></line>
                <line x1="9" y1="9" x2="15" y2="15"></line>
              </svg>
            </div>
            <div className="alert-content">
              <div className="alert-title">خطا</div>
              <div className="alert-message">{error}</div>
            </div>
            <button className="alert-close" onClick={() => setError(null)}>
              <svg viewBox="0 0 24 24" width="16" height="16" fill="none" stroke="currentColor" strokeWidth="2">
                <line x1="18" y1="6" x2="6" y2="18"></line>
                <line x1="6" y1="6" x2="18" y2="18"></line>
              </svg>
            </button>
          </div>
        )}

        {loading && !currentLocation && (
          <div className="alert-toast info-alert">
            <div className="alert-icon spinning">
              <svg viewBox="0 0 24 24" width="20" height="20" fill="none" stroke="currentColor" strokeWidth="2">
                <circle cx="12" cy="12" r="10"></circle>
                <path d="M12 6v6l4 2"></path>
              </svg>
            </div>
            <div className="alert-content">
              <div className="alert-message">در حال یافتن موقعیت شما...</div>
            </div>
          </div>
        )}
      </div>
    </div>
  );
};

export default MapPage;  ```   
   
## \src\pages\NotFoundPage.jsx   
```javascript   
import React from 'react';  
import { Link } from 'react-router-dom';  

export const NotFoundPage = () => {  
  return (  
    <div className="not-found-page">  
      <h1>404</h1>  
      <h2>صفحه مورد نظر یافت نشد</h2>  
      <p>متاسفانه صفحه‌ای که به دنبال آن هستید وجود ندارد.</p>  
      <Link to="/" className="btn btn-primary">  
        بازگشت به صفحه اصلی  
      </Link>  
    </div>  
  );  
};  

// سطر زیر اضافه نشود - به جای آن از { NotFoundPage } در import استفاده شود  
// export default NotFoundPage;  ```   
   
## \src\pages\QRScanPage.jsx   
```javascript   
import React, { useState } from 'react';  
// فعلاً QRScanner را import نمی‌کنیم تا مشکل آن جداگانه حل شود  
// import QRScanner from '../components/map/QRScanner';  

export const QRScanPage = () => {  
  const [isScanning, setIsScanning] = useState(false);  
  const [scanResult, setScanResult] = useState(null);  
  const [scanError, setScanError] = useState(null);  

  const handleStartScan = () => {  
    setIsScanning(true);  
    setScanError(null);  
    setScanResult(null);  
    
    // این بخش بعداً به کامپوننت QRScanner متصل می‌شود  
    console.log("شروع اسکن QR...");  
  };  
  
  const handleScanSuccess = (result) => {  
    console.log("QR اسکن شد:", result);  
    setIsScanning(false);  
    setScanResult({  
      qrData: result,  
      location: { coords: { lat: 35.6892, lng: 51.3890 } }, // مقدار نمونه  
      timestamp: new Date().toISOString()  
    });  
  };  
  
  const handleScanError = (error) => {  
    console.error("خطای اسکن:", error);  
    setScanError(`خطا در اسکن: ${error?.message || 'خطای ناشناخته'}`);  
    setIsScanning(false);  
  };  

  return (  
    <div className="qr-scan-page">  
      <h2>اسکن QR Code</h2>  
      
      {scanError && (  
        <div className="error-container">  
          <p className="error-message">{scanError}</p>  
          <button onClick={handleStartScan} className="btn btn-primary">تلاش مجدد</button>  
        </div>  
      )}  
      
      {!isScanning && !scanResult && !scanError && (  
        <div className="start-scan-container">  
          <p>برای اسکن QR Code مربوط به موقعیت، دکمه زیر را فشار دهید.</p>  
          <button onClick={handleStartScan} className="btn btn-primary">شروع اسکن QR</button>  
        </div>  
      )}  
      
      {isScanning && (  
        <div className="scanner-container">  
          <p className="scan-instruction">QR Code را مقابل دوربین قرار دهید</p>  
          
          {/* فعلاً کامپوننت QRScanner را کامنت می‌کنیم */}  
          {/* <QRScanner   
            onSuccess={handleScanSuccess}  
            onError={handleScanError}  
          /> */}  
          
          <div className="scanner-placeholder">  
            <p>اسکنر QR کد...</p>  
            <button onClick={() => handleScanSuccess("https://example.com/location/12345")}>  
              شبیه‌سازی اسکن موفق  
            </button>  
            <button onClick={() => handleScanError(new Error("دسترسی به دوربین مقدور نیست"))}>  
              شبیه‌سازی خطا  
            </button>  
          </div>  
        </div>  
      )}  
      
      {scanResult && (  
        <div className="scan-result-container">  
          <h3>QR Code با موفقیت اسکن شد</h3>  
          <div className="result-data">  
            <p className="qr-data">{scanResult.qrData}</p>  
            {scanResult.location && (  
              <div className="location-data">  
                <p>موقعیت اسکن:</p>  
                <p>عرض جغرافیایی: {scanResult.location.coords.lat.toFixed(6)}</p>  
                <p>طول جغرافیایی: {scanResult.location.coords.lng.toFixed(6)}</p>  
              </div>  
            )}  
            <p className="scan-time">  
              زمان اسکن: {new Date(scanResult.timestamp).toLocaleString('fa-IR')}  
            </p>  
          </div>  
          
          <div className="action-buttons">  
            <button className="btn btn-primary">  
              نمایش روی نقشه  
            </button>  
            <button onClick={handleStartScan} className="btn btn-secondary">  
              اسکن دوباره  
            </button>  
          </div>  
        </div>  
      )}  
    </div>  
  );  
};  

// سطر زیر اضافه نشود - به جای آن از { QRScanPage } در import استفاده شود  
// export default QRScanPage;  ```   
   
## \src\pages\SettingsPage.jsx   
```javascript   
// src/pages/SettingsPage.jsx  
import React, { useState, useEffect } from 'react';
import { Link } from 'react-router-dom';
import { LogStorageService } from '../services/LogStorageService';
import './SettingsPage.css';

const SettingsPage = () => {
  const [logCounts, setLogCounts] = useState({ gpsLogs: 0, trackLogs: 0 });
  const [storageSize, setStorageSize] = useState({ gpsLogsSize: 0, trackLogsSize: 0, totalSize: 0 });
  const [isLoading, setIsLoading] = useState(true);
  const [isExporting, setIsExporting] = useState(false);
  const [message, setMessage] = useState('');

  // دریافت آمار لاگ‌ها  
  useEffect(() => {
    async function fetchLogStats() {
      try {
        setIsLoading(true);
        const counts = await LogStorageService.getLogCounts();
        const size = await LogStorageService.estimateStorageSize();

        setLogCounts(counts);
        setStorageSize(size);
        setIsLoading(false);
      } catch (error) {
        console.error('خطا در دریافت آمار لاگ‌ها:', error);
        setMessage('خطا در دریافت آمار لاگ‌ها');
        setIsLoading(false);
      }
    }

    fetchLogStats();
  }, []);

  // تبدیل بایت به نمایش انسانی  
  const formatSize = (bytes) => {
    if (bytes === 0) return '0 بایت';

    const k = 1024;
    const sizes = ['بایت', 'کیلوبایت', 'مگابایت', 'گیگابایت'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));

    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
  };

  // خروجی‌گیری لاگ‌های GPS به صورت JSON  
  const exportGPSLogsAsJSON = async () => {
    try {
      setIsExporting(true);
      setMessage('در حال خروجی‌گیری از لاگ‌های GPS...');

      const json = await LogStorageService.exportGPSLogsAsJSON();
      LogStorageService.downloadFile(json, `gps_logs_${new Date().toISOString()}.json`, 'application/json');

      setMessage('خروجی‌گیری با موفقیت انجام شد');
      setIsExporting(false);
    } catch (error) {
      console.error('خطا در خروجی‌گیری لاگ‌های GPS:', error);
      setMessage('خطا در خروجی‌گیری لاگ‌های GPS');
      setIsExporting(false);
    }
  };

  // خروجی‌گیری لاگ‌های GPS به صورت CSV  
  const exportGPSLogsAsCSV = async () => {
    try {
      setIsExporting(true);
      setMessage('در حال خروجی‌گیری از لاگ‌های GPS...');

      const csv = await LogStorageService.exportGPSLogsAsCSV();
      LogStorageService.downloadFile(csv, `gps_logs_${new Date().toISOString()}.csv`, 'text/csv');

      setMessage('خروجی‌گیری با موفقیت انجام شد');
      setIsExporting(false);
    } catch (error) {
      console.error('خطا در خروجی‌گیری لاگ‌های GPS:', error);
      setMessage('خطا در خروجی‌گیری لاگ‌های GPS');
      setIsExporting(false);
    }
  };

  // خروجی‌گیری مسیرها به صورت GeoJSON  
  const exportTracksAsGeoJSON = async () => {
    try {
      setIsExporting(true);
      setMessage('در حال خروجی‌گیری از مسیرها...');

      const geoJSON = await LogStorageService.exportTrackLogsAsGeoJSON();
      LogStorageService.downloadFile(geoJSON, `tracks_${new Date().toISOString()}.geojson`, 'application/geo+json');

      setMessage('خروجی‌گیری با موفقیت انجام شد');
      setIsExporting(false);
    } catch (error) {
      console.error('خطا در خروجی‌گیری مسیرها:', error);
      setMessage('خطا در خروجی‌گیری مسیرها');
      setIsExporting(false);
    }
  };

  // پاک کردن لاگ‌های GPS  
  const clearGPSLogs = async () => {
    try {
      if (window.confirm('آیا مطمئن هستید که می‌خواهید همه لاگ‌های GPS را پاک کنید؟ این عمل غیرقابل بازگشت است.')) {
        setIsLoading(true);
        setMessage('در حال پاک کردن لاگ‌های GPS...');

        await LogStorageService.clearGPSLogs();

        // به‌روزرسانی آمار  
        const counts = await LogStorageService.getLogCounts();
        const size = await LogStorageService.estimateStorageSize();

        setLogCounts(counts);
        setStorageSize(size);
        setMessage('لاگ‌های GPS با موفقیت پاک شدند');
        setIsLoading(false);
      }
    } catch (error) {
      console.error('خطا در پاک کردن لاگ‌های GPS:', error);
      setMessage('خطا در پاک کردن لاگ‌های GPS');
      setIsLoading(false);
    }
  };

  // پاک کردن لاگ‌های مسیر  
  const clearTrackLogs = async () => {
    try {
      if (window.confirm('آیا مطمئن هستید که می‌خواهید همه لاگ‌های مسیر را پاک کنید؟ این عمل غیرقابل بازگشت است.')) {
        setIsLoading(true);
        setMessage('در حال پاک کردن لاگ‌های مسیر...');

        await LogStorageService.clearTrackLogs();

        // به‌روزرسانی آمار  
        const counts = await LogStorageService.getLogCounts();
        const size = await LogStorageService.estimateStorageSize();

        setLogCounts(counts);
        setStorageSize(size);
        setMessage('لاگ‌های مسیر با موفقیت پاک شدند');
        setIsLoading(false);
      }
    } catch (error) {
      console.error('خطا در پاک کردن لاگ‌های مسیر:', error);
      setMessage('خطا در پاک کردن لاگ‌های مسیر');
      setIsLoading(false);
    }
  };

  return (
    <div className="settings-page">
      <div className="settings-header">
        <Link to="/" className="back-button">
          <svg viewBox="0 0 24 24" width="16" height="16" stroke="currentColor" strokeWidth="2" fill="none">
            <path d="M19 12H5M12 19l-7-7 7-7" />
          </svg>
          <span>بازگشت</span>
        </Link>
        <h1>تنظیمات</h1>
      </div>

      <div className="settings-content">
        <section className="setting-section logs-section">
          <h2>مدیریت لاگ‌ها</h2>

          {isLoading ? (
            <div className="loading">در حال بارگذاری آمار لاگ‌ها...</div>
          ) : (
            <div className="logs-stats">
              <div className="stat-item">
                <span>تعداد لاگ‌های GPS:</span>
                <span className="stat-value">{logCounts.gpsLogs.toLocaleString('fa-IR')}</span>
              </div>
              <div className="stat-item">
                <span>تعداد مسیرهای ذخیره شده:</span>
                <span className="stat-value">{logCounts.trackLogs.toLocaleString('fa-IR')}</span>
              </div>
              <div className="stat-item">
                <span>حجم تقریبی لاگ‌های GPS:</span>
                <span className="stat-value">{formatSize(storageSize.gpsLogsSize)}</span>
              </div>
              <div className="stat-item">
                <span>حجم تقریبی مسیرها:</span>
                <span className="stat-value">{formatSize(storageSize.trackLogsSize)}</span>
              </div>
              <div className="stat-item total-size">
                <span>حجم کل:</span>
                <span className="stat-value">{formatSize(storageSize.totalSize)}</span>
              </div>
            </div>
          )}

          <div className="export-section">
            <h3>خروجی‌گیری از لاگ‌ها</h3>
            <div className="button-group">
              <button
                className="export-button"
                onClick={exportGPSLogsAsJSON}
                disabled={isExporting || logCounts.gpsLogs === 0}
              >
                <svg viewBox="0 0 24 24" width="16" height="16" fill="none" stroke="currentColor" strokeWidth="2">
                  <path d="M21 15v4a2 2 0 01-2 2H5a2 2 0 01-2-2v-4M7 10l5 5 5-5M12 15V3"></path>
                </svg>
                خروجی JSON لاگ‌های GPS
              </button>

              <button
                className="export-button"
                onClick={exportGPSLogsAsCSV}
                disabled={isExporting || logCounts.gpsLogs === 0}
              >
                <svg viewBox="0 0 24 24" width="16" height="16" fill="none" stroke="currentColor" strokeWidth="2">
                  <path d="M21 15v4a2 2 0 01-2 2H5a2 2 0 01-2-2v-4M7 10l5 5 5-5M12 15V3"></path>
                </svg>
                خروجی CSV لاگ‌های GPS
              </button>

              <button
                className="export-button"
                onClick={exportTracksAsGeoJSON}
                disabled={isExporting || logCounts.trackLogs === 0}
              >
                <svg viewBox="0 0 24 24" width="16" height="16" fill="none" stroke="currentColor" strokeWidth="2">
                  <path d="M21 15v4a2 2 0 01-2 2H5a2 2 0 01-2-2v-4M7 10l5 5 5-5M12 15V3"></path>
                </svg>
                خروجی GeoJSON مسیرها
              </button>
            </div>
          </div>

          <div className="clear-section">
            <h3>پاک کردن لاگ‌ها</h3>
            <div className="button-group">
              <button
                className="settings-clear-button danger" // تغییر از clear-button به settings-clear-button  
                onClick={clearGPSLogs}
                disabled={isLoading || logCounts.gpsLogs === 0}
              >
                <svg viewBox="0 0 24 24" width="16" height="16" fill="none" stroke="currentColor" strokeWidth="2">
                  <polyline points="3 6 5 6 21 6"></polyline>
                  <path d="M19 6v14a2 2 0 01-2 2H7a2 2 0 01-2-2V6m3 0V4a2 2 0 012-2h4a2 2 0 012 2v2"></path>
                </svg>
                پاک کردن لاگ‌های GPS
              </button>

              <button
                className="settings-clear-button danger" // تغییر از clear-button به settings-clear-button  
                onClick={clearTrackLogs}
                disabled={isLoading || logCounts.trackLogs === 0}
              >
                <svg viewBox="0 0 24 24" width="16" height="16" fill="none" stroke="currentColor" strokeWidth="2">
                  <polyline points="3 6 5 6 21 6"></polyline>
                  <path d="M19 6v14a2 2 0 01-2 2H7a2 2 0 01-2-2V6m3 0V4a2 2 0 012-2h4a2 2 0 012 2v2"></path>
                </svg>
                پاک کردن مسیرها
              </button>
            </div>
          </div>

          {message && (
            <div className={`message ${message.includes('خطا') ? 'error' : 'success'}`}>
              {message}
            </div>
          )}
        </section>

        <section className="setting-section about-section">
          <h2>درباره برنامه</h2>
          <p>
            این برنامه برای ردیابی موقعیت GPS و تشخیص اختلال در سیگنال طراحی شده است.
            کلیه داده‌ها به صورت محلی در دستگاه شما ذخیره می‌شوند و هیچ اطلاعاتی به سرور ارسال نمی‌شود.
          </p>
          <p>
            نسخه: 1.0.0
          </p>
        </section>
      </div>
    </div>
  );
};

//export default SettingsPage; 
export { SettingsPage };  ```   
   
## \src\pages\SettingsPage.css   
```javascript   
/* src/pages/SettingsPage.css */  
.settings-page {  
  display: flex;  
  flex-direction: column;  
  max-width: 100%;  
  height: 100vh;  
  padding: 0;  
  margin: 0;  
  font-family: 'Vazirmatn', sans-serif;  
  background-color: #f5f5f5;  
  direction: rtl;  
}  

.settings-header {  
  display: flex;  
  align-items: center;  
  padding: 1rem;  
  background-color: #ffffff;  
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);  
  position: sticky;  
  top: 0;  
  z-index: 100;  
}  

.settings-header h1 {  
  margin: 0 1rem;  
  font-size: 1.25rem;  
  font-weight: 600;  
}  

.back-button {  
  display: flex;  
  align-items: center;  
  text-decoration: none;  
  color: #333;  
  font-size: 0.9rem;  
}  

.back-button svg {  
  margin-left: 0.25rem;  
}  

.settings-content {  
  padding: 1rem;  
  flex: 1;  
  overflow-y: auto;  
}  

.setting-section {  
  background-color: #ffffff;  
  border-radius: 8px;  
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);  
  padding: 1rem;  
  margin-bottom: 1rem;  
}  

.setting-section h2 {  
  margin-top: 0;  
  margin-bottom: 1rem;  
  font-size: 1.1rem;  
  color: #333;  
  border-bottom: 1px solid #eee;  
  padding-bottom: 0.5rem;  
}  

.setting-section h3 {  
  font-size: 1rem;  
  margin: 1rem 0 0.5rem;  
  color: #444;  
}  

.logs-stats {  
  display: flex;  
  flex-direction: column;  
  gap: 0.75rem;  
  margin-bottom: 1.5rem;  
}  

.stat-item {  
  display: flex;  
  justify-content: space-between;  
  padding: 0.25rem 0;  
}  

.stat-value {  
  font-weight: 600;  
  color: #333;  
}  

.total-size {  
  margin-top: 0.5rem;  
  padding-top: 0.5rem;  
  border-top: 1px dashed #eee;  
}  

.button-group {  
  display: flex;  
  flex-direction: column;  
  gap: 0.75rem;  
  margin: 0.75rem 0;  
}  

.export-button, .settings-clear-button {  
  display: flex;  
  align-items: center;  
  justify-content: center;  
  gap: 0.5rem;  
  padding: 0.75rem;  
  border-radius: 4px;  
  font-family: 'Vazirmatn', sans-serif;  
  font-size: 0.9rem;  
  cursor: pointer;  
  transition: all 0.2s ease;  
  border: none;  
  background-color: #f5f5f5;  
}  

.export-button svg, .settings-clear-button svg {  
  width: 16px;  
  height: 16px;  
}  

.export-button:hover {  
  background-color: #e0e0e0;  
}  

.export-button:disabled, .settings-clear-button:disabled {  
  opacity: 0.5;  
  cursor: not-allowed;  
}  

.danger {  
  background-color: #fff0f0;  
  color: #e53935;  
}  

.danger:hover {  
  background-color: #ffcdd2;  
}  

.message {  
  margin-top: 1rem;  
  padding: 0.75rem;  
  border-radius: 4px;  
  font-size: 0.9rem;  
  text-align: center;  
}  

.message.success {  
  background-color: #e8f5e9;  
  color: #2e7d32;  
}  

.message.error {  
  background-color: #ffebee;  
  color: #c62828;  
}  

.loading {  
  text-align: center;  
  padding: 1rem;  
  color: #757575;  
  font-size: 0.9rem;  
}  

.about-section p {  
  font-size: 0.9rem;  
  line-height: 1.5;  
  color: #555;  
}  

@media (min-width: 768px) {  
  .button-group {  
    flex-direction: row;  
    flex-wrap: wrap;  
  }  
  
  .export-button, .settings-clear-button {  
    flex: 1;  
    min-width: 200px;  
  }  
}  
```   
   
## \src\services\AdvancedDeadReckoningService.js   
```javascript   
// src/services/AdvancedDeadReckoningService.js  
import { KalmanFilter } from './KalmanFilter';
import { LowPassFilter } from '../utils/LowPassFilter';
import { HighPassFilter } from '../utils/HighPassFilter';
import { PeakDetector } from '../utils/PeakDetector';

/**  
 * سرویس Dead Reckoning پیشرفته با Sensor Fusion  
 * ترکیب داده‌های سنسورهای IMU (شتاب‌سنج، ژیروسکوپ، مگنتومتر) و GPS  
 * با استفاده از Extended Kalman Filter  
 */
class AdvancedDeadReckoningService {
    // متد کمکی تبدیل رادیان به درجه  
    _toDegrees(rad) {
        return rad * 180 / Math.PI;
    }
    
    constructor() {
        // وضعیت سرویس  
        this.isActive = false;
        this.isCalibrating = false;
        this.calibrationStart = 0;
        this.calibrationDuration = 2000; // زمان کالیبراسیون به میلی‌ثانیه (2 ثانیه)  

        // فیلترها برای پردازش داده‌های سنسور  
        this.accelerometerLowPassFilter = new LowPassFilter(0.1); // آلفا کوچک‌تر = فیلترینگ قوی‌تر  
        this.gyroscopeLowPassFilter = new LowPassFilter(0.2);
        this.orientationLowPassFilter = new LowPassFilter(0.1);
        this.accelerometerHighPassFilter = new HighPassFilter(0.8); // آلفا بزرگ‌تر = فیلترینگ قوی‌تر  

        // تشخیص گام (Peak Detector)  
        this.peakDetector = new PeakDetector({
            threshold: 0.8,       // آستانه تشخیص پیک  
            minPeakDistance: 300, // حداقل فاصله زمانی بین پیک‌ها (میلی‌ثانیه)  
            windowSize: 10        // تعداد نمونه‌هایی که برای تشخیص پیک بررسی می‌شوند  
        });

        // مقادیر کالیبراسیون  
        this.accelerometerBias = { x: 0, y: 0, z: 0 };
        this.gyroscopeBias = { alpha: 0, beta: 0, gamma: 0 };
        this.magneticDeclination = 0; // انحراف مغناطیسی (بر حسب رادیان)  

        // موقعیت و مسیر  
        this.referencePosition = null; // نقطه مرجع GPS برای تبدیل مختصات نسبی به مطلق  
        this.currentPosition = { x: 0, y: 0, theta: 0 }; // موقعیت نسبی (متر) و جهت (رادیان)  
        this.path = []; // مسیر نسبی (x, y در متر)  
        this.geoPath = []; // مسیر جغرافیایی (lat, lng)  

        // شمارش گام و طول گام  
        this.stepCount = 0;
        this.strideLength = 0.75; // طول گام پیش‌فرض (متر)  

        // فیلتر کالمن برای Sensor Fusion  
        this.kalmanFilter = new KalmanFilter({
            stateSize: 6,         // [x, y, theta, v, w, stride]  
            measurementSize: 3,   // [x_gps, y_gps, heading]  
            controlSize: 2,       // [a_norm, omega]  
        });

        // متغیرهای زمانی  
        this.lastUpdateTime = 0;
        this.lastStepTime = 0;

        // ذخیره آخرین مقادیر سنسورها  
        this.lastAccelerometer = null;
        this.lastGyroscope = null;
        this.lastOrientation = null;
        this.lastGps = null;

        // متغیرهای کمکی  
        this._initialHeading = null; // جهت اولیه  
        this._accelNormHistory = []; // تاریخچه نُرم شتاب برای تشخیص گام  
        this._listeners = [];        // لیستنرها برای اطلاع‌رسانی تغییرات  

        // لاگ برای تحلیل و دیباگ  
        this._log = {
            timestamp: [],
            sensor: [],
            data: [],
            result: []
        };
    }

    /**  
     * فعال/غیرفعال کردن سرویس  
     * @param {Object} initialLatLng موقعیت GPS اولیه برای استفاده به عنوان نقطه مرجع  
     * @returns {boolean} وضعیت جدید (فعال یا غیرفعال)  
     */
    toggle(initialLatLng = null) {
        // وضعیت قبلی  
        const wasActive = this.isActive;
        // تغییر وضعیت  
        this.isActive = !wasActive;

        if (this.isActive) {
            // استارت سرویس  
            console.log('Starting Advanced Dead Reckoning Service');

            // ابتدا کالیبراسیون را فعال کنید  
            this.isCalibrating = true;
            this.calibrationStart = Date.now();

            // پاکسازی مقادیر قبلی  
            this.path = [];
            this.geoPath = [];
            this.stepCount = 0;
            this._accelNormHistory = [];
            this.lastUpdateTime = Date.now();
            this.lastStepTime = 0;

            // مقداردهی اولیه فیلتر کالمن  
            this.kalmanFilter.initialize({
                x: 0,
                y: 0,
                theta: this._initialHeading || 0,
                v: 0,
                w: 0,
                stride: this.strideLength,
                timestamp: Date.now()
            });

            // اگر موقعیت اولیه ارسال شده است، از آن استفاده کنید  
            if (initialLatLng &&
                initialLatLng.lat !== undefined &&
                initialLatLng.lng !== undefined &&
                !isNaN(initialLatLng.lat) &&
                !isNaN(initialLatLng.lng)) {

                console.log('Setting initial reference position:', initialLatLng);

                this.referencePosition = {
                    lat: initialLatLng.lat,
                    lng: initialLatLng.lng,
                    accuracy: initialLatLng.accuracy || 5.0,
                    timestamp: Date.now()
                };

                // ثبت نقطه اول در مسیر نسبی و جغرافیایی  
                this.path.push({ x: 0, y: 0, timestamp: Date.now() });
                this.geoPath.push({
                    lat: initialLatLng.lat,
                    lng: initialLatLng.lng,
                    timestamp: Date.now()
                });

                this.currentPosition = { x: 0, y: 0, theta: this._initialHeading || 0 };

                // اطلاع‌رسانی به لیستنرها  
                this._notify({
                    type: 'serviceStateChanged',
                    isActive: this.isActive,
                    isCalibrating: this.isCalibrating,
                    stepCount: this.stepCount,
                    kalmanState: this.kalmanFilter.getState(),
                    path: this.path,
                    geoPath: this.geoPath,
                    position: this.currentPosition,
                    geoPosition: {
                        lat: initialLatLng.lat,
                        lng: initialLatLng.lng,
                        heading: this._toDegrees(this.kalmanFilter.getState().theta)
                    }
                });
            } else {
                console.warn('No valid initial position provided. GPS will be used when available.');

                // اطلاع‌رسانی به لیستنرها بدون داده موقعیت  
                this._notify({
                    type: 'serviceStateChanged',
                    isActive: this.isActive,
                    isCalibrating: this.isCalibrating,
                    stepCount: this.stepCount,
                    kalmanState: this.kalmanFilter.getState(),
                    path: this.path,
                    geoPath: this.geoPath
                });
            }
        } else {
            // توقف سرویس  
            console.log('Stopping Advanced Dead Reckoning Service');

            // اطلاع‌رسانی به لیستنرها  
            this._notify({
                type: 'serviceStateChanged',
                isActive: this.isActive,
                isCalibrating: false,
                kalmanState: this.kalmanFilter.getState(),
                path: this.path,
                geoPath: this.geoPath
            });
        }

        return this.isActive;
    }
    /**  
     * بازنشانی سرویس و پاکسازی داده‌ها  
     */
    reset() {
        if (!this.isActive) return;

        console.log('Resetting Advanced Dead Reckoning Service');

        // پاکسازی مسیر و داده‌ها  
        this.path = [];
        this.geoPath = [];
        this.stepCount = 0;
        this._accelNormHistory = [];

        // مقداردهی مجدد موقعیت نسبی  
        this.currentPosition = { x: 0, y: 0, theta: 0 };

        // اگر موقعیت مرجع وجود دارد، اولین نقطه مسیر را دوباره ثبت کنید  
        if (this.referencePosition) {
            this.path.push({ x: 0, y: 0, timestamp: Date.now() });
            this.geoPath.push({
                lat: this.referencePosition.lat,
                lng: this.referencePosition.lng,
                timestamp: Date.now()
            });
        }

        // مقداردهی مجدد فیلتر کالمن  
        this.kalmanFilter.initialize({
            x: 0,
            y: 0,
            theta: this._initialHeading || 0,
            v: 0,
            w: 0,
            stride: this.strideLength,
            timestamp: Date.now()
        });

        // اطلاع‌رسانی به لیستنرها  
        this._notify({
            type: 'serviceReset',
            stepCount: this.stepCount,
            kalmanState: this.kalmanFilter.getState(),
            path: this.path,
            geoPath: this.geoPath
        });
    }

    /**  
     * تنظیم طول گام  
     * @param {number} strideLength طول گام جدید (متر)  
     */
    setStrideLength(strideLength) {
        if (strideLength > 0) {
            this.strideLength = strideLength;

            // در صورت فعال بودن، طول گام را در فیلتر کالمن نیز به‌روز کنید  
            if (this.isActive) {
                this.kalmanFilter.setStrideLength(strideLength);
            }

            // اطلاع‌رسانی به لیستنرها  
            this._notify({
                type: 'strideLengthChanged',
                strideLength: this.strideLength
            });
        }
    }

    /**  
     * پردازش داده‌های شتاب‌سنج  
     */
    processAccelerometerData(data, timestamp = Date.now()) {
        if (!this.isActive || !data) return;

        // بررسی معتبر بودن داده‌ها  
        if (data.x === undefined || data.y === undefined || data.z === undefined ||
            isNaN(data.x) || isNaN(data.y) || isNaN(data.z)) {
            console.warn('داده‌های نامعتبر شتاب‌سنج:', data);
            return;
        }

        // لاگ کردن داده‌ها  
        this._logSensorData('accelerometer', data, timestamp);

        // تنظیم محور‌ها براساس جهت نگهداری گوشی  
        // در اینجا فرض می‌کنیم که کاربر گوشی را عمودی (portrait) نگه می‌دارد  
        let ax = 0, ay = 0, az = 0;

        // بررسی نوع داده‌های شتاب‌سنج (با جاذبه یا بدون جاذبه)  
        if (data.includesGravity) {
            // داده شامل جاذبه است (accelerationIncludingGravity)  
            // در حالت portrait: x = راست/چپ, y = بالا/پایین, z = جلو/عقب  
            ax = data.x;
            ay = data.y;
            az = data.z;

            // اگر فیلتر پایین‌گذر فعال نیست، آن را فعال کنید  
            if (!this._lowPassFilter) {
                this._lowPassFilter = new LowPassFilter(0.1);
            }

            // حذف تقریبی جاذبه با فیلتر پایین‌گذر  
            const gravity = this._lowPassFilter.filter([ax, ay, az]);
            ax -= gravity[0];
            ay -= gravity[1];
            az -= gravity[2];
        } else {
            // داده بدون جاذبه (acceleration)  
            ax = data.x;
            ay = data.y;
            az = data.z;
        }

        // اگر فیلتر بالاگذر فعال نیست، آن را فعال کنید  
        if (!this._highPassFilter) {
            this._highPassFilter = new HighPassFilter(0.8);
        }

        // اعمال فیلتر بالاگذر برای حذف نویز و drift کم‌فرکانس  
        const filteredAcc = this._highPassFilter.filter([ax, ay, az]);
        ax = filteredAcc[0];
        ay = filteredAcc[1];
        az = filteredAcc[2];

        // محاسبه سیگنال نُرم شتاب  
        const accelNorm = Math.sqrt(ax * ax + ay * ay + az * az);

        // محافظت در برابر مقادیر نامعتبر  
        if (isNaN(accelNorm)) {
            console.warn('مقدار نامعتبر در نُرم شتاب:', { ax, ay, az, accelNorm });
            return;
        }

        // افزودن به تاریخچه نُرم شتاب  
        this._accelNormHistory.push({ value: accelNorm, timestamp });

        // حفظ فقط آخرین N نمونه شتاب  
        const historyWindow = 50; // حفظ 50 نمونه آخر  
        if (this._accelNormHistory.length > historyWindow) {
            this._accelNormHistory = this._accelNormHistory.slice(-historyWindow);
        }

        // آستانه‌های تشخیص گام  
        const minPeakHeight = 1.2;  // حداقل ارتفاع قله  
        const minTimeBetweenSteps = 400; // حداقل زمان بین گام‌ها (میلی‌ثانیه)  

        // فقط در صورتی که کالیبراسیون تمام شده است  
        if (!this.isCalibrating && this._accelNormHistory.length >= 10) {
            // بررسی برای تشخیص قله  
            if (this._isPeak(this._accelNormHistory, minPeakHeight)) {
                const currentTime = timestamp;
                // بررسی فاصله زمانی از آخرین گام  
                if (currentTime - this.lastStepTime > minTimeBetweenSteps) {
                    // یک گام جدید شناسایی شد  
                    this.stepCount++;
                    this.lastStepTime = currentTime;

                    // به‌روزرسانی فیلتر کالمن با ورودی تشخیص گام  
                    const dt = (currentTime - this.lastUpdateTime) / 1000.0;
                    this.lastUpdateTime = currentTime;

                    // ورودی کنترل: a_norm = 1 نشان‌دهنده تشخیص یک گام است  
                    const controlInput = {
                        a_norm: 1,
                        omega: this.lastGyro ? this.lastGyro.alpha * Math.PI / 180 : 0
                    };

                    // پیش‌بینی فیلتر کالمن  
                    this.kalmanFilter.predict(controlInput, currentTime);

                    // به‌روزرسانی موقعیت فعلی از فیلتر کالمن  
                    const kalmanState = this.kalmanFilter.getState();

                    // محافظت در برابر مقادیر نامعتبر  
                    if (isNaN(kalmanState.x) || isNaN(kalmanState.y) || isNaN(kalmanState.theta)) {
                        console.warn('مقادیر نامعتبر در وضعیت کالمن:', kalmanState);
                        return;
                    }

                    // ثبت موقعیت نسبی جدید  
                    this.currentPosition = {
                        x: kalmanState.x,
                        y: kalmanState.y,
                        theta: kalmanState.theta
                    };

                    // تبدیل موقعیت نسبی به مختصات جغرافیایی  
                    if (this.referencePosition) {
                        const currentGeoPosition = this._calculateNewLatLng(
                            this.referencePosition.lat,
                            this.referencePosition.lng,
                            this.currentPosition.x,
                            this.currentPosition.y
                        );

                        // محافظت در برابر مقادیر نامعتبر  
                        if (isNaN(currentGeoPosition.lat) || isNaN(currentGeoPosition.lng)) {
                            console.warn('مقادیر نامعتبر در موقعیت جغرافیایی:', currentGeoPosition);
                            return;
                        }

                        // افزودن نقطه به مسیر  
                        this.path.push({
                            x: this.currentPosition.x,
                            y: this.currentPosition.y,
                            timestamp: currentTime
                        });

                        this.geoPath.push({
                            lat: currentGeoPosition.lat,
                            lng: currentGeoPosition.lng,
                            timestamp: currentTime
                        });

                        // لاگ کردن اطلاعات گام  
                        console.log(`[Step ${this.stepCount}] Pos: (${this.currentPosition.x.toFixed(2)}, ${this.currentPosition.y.toFixed(2)}) GeoPos: (${currentGeoPosition.lat.toFixed(6)}, ${currentGeoPosition.lng.toFixed(6)})`);

                        // اطلاع‌رسانی به لیستنرها  
                        this._notify({
                            type: 'step',
                            stepCount: this.stepCount,
                            position: {
                                x: this.currentPosition.x,
                                y: this.currentPosition.y,
                                theta: this.currentPosition.theta
                            },
                            geoPosition: {
                                lat: currentGeoPosition.lat,
                                lng: currentGeoPosition.lng,
                                heading: this._toDegrees(this.currentPosition.theta)
                            },
                            kalmanState: this.kalmanFilter.getState(),
                            path: this.path,
                            geoPath: this.geoPath
                        });
                    }
                }
            }
        } else if (this.isCalibrating) {
            // در حالت کالیبراسیون داده‌ها را جمع‌آوری می‌کنیم  
            const calibrationTime = 2000; // زمان کالیبراسیون (میلی‌ثانیه)  

            if (Date.now() - this.calibrationStart > calibrationTime) {
                // کالیبراسیون کامل شد  
                this.isCalibrating = false;
                console.log('Calibration complete');

                // اطلاع‌رسانی به لیستنرها  
                this._notify({
                    type: 'calibrationComplete',
                    isCalibrating: false,
                    path: this.path,
                    geoPath: this.geoPath
                });
            }
        }
    }

    /**  
     * بررسی وجود قله در داده‌های شتاب  
     * @param {Array} history تاریخچه داده‌های نُرم شتاب  
     * @param {number} threshold آستانه ارتفاع قله  
     * @returns {boolean} آیا نقطه انتهایی یک قله است  
     */
    _isPeak(history, threshold) {
        if (history.length < 3) return false;

        // بررسی 3 نمونه آخر  
        const last = history[history.length - 1].value;
        const previous = history[history.length - 2].value;
        const beforePrevious = history[history.length - 3].value;

        // شرایط قله:  
        // 1. نقطه میانی باید از دو طرف بزرگتر باشد  
        // 2. نقطه میانی باید از آستانه بزرگتر باشد  
        return (previous > last && previous > beforePrevious && previous > threshold);
    }

    /**  
     * پردازش داده‌های ژیروسکوپ  
     * @param {Object} gyroscope داده‌های ژیروسکوپ {alpha, beta, gamma, timestamp}  
     * @param {number} timestamp زمان دریافت داده  
     */
    processGyroscopeData(gyroscope, timestamp = Date.now()) {
        if (!this.isActive) return;

        // لاگ داده‌های ورودی  
        this._logSensorData('gyroscope', gyroscope, timestamp);

        // فیلتر داده‌های ژیروسکوپ  
        const filteredGyro = this._filterGyroscopeData(gyroscope);

        // پردازش داده‌های سنسور برای به‌روزرسانی موقعیت  
        this._processSensorData({
            type: 'gyroscope',
            data: filteredGyro,
            timestamp: timestamp
        });

        // ذخیره آخرین داده‌های ژیروسکوپ  
        this.lastGyroscope = {
            ...filteredGyro,
            timestamp: timestamp
        };
    }

    /**  
     * پردازش داده‌های جهت (مگنتومتر)  
     * @param {Object} orientation داده‌های جهت {alpha, beta, gamma, timestamp}  
     * @param {number} timestamp زمان دریافت داده  
     */
    processOrientationData(orientation, timestamp = Date.now()) {
        if (!this.isActive) return;

        // لاگ داده‌های ورودی  
        this._logSensorData('orientation', orientation, timestamp);

        // فیلتر داده‌های جهت  
        const filteredOrientation = this._filterOrientationData(orientation);

        // تبدیل alpha از درجه به رادیان (0-360 به 0-2π)  
        const heading = (filteredOrientation.alpha * Math.PI) / 180;

        // ذخیره جهت اولیه اگر تنظیم نشده است  
        if (this._initialHeading === null && orientation.absolute) {
            this._initialHeading = heading;

            // تنظیم جهت اولیه در فیلتر کالمن اگر تازه مقداردهی شده است  
            if (this.kalmanFilter) {
                const state = this.kalmanFilter.getState();
                state.theta = heading;
                this.kalmanFilter.initialize(state);
            }
        }

        // پردازش داده‌های سنسور برای به‌روزرسانی موقعیت  
        this._processSensorData({
            type: 'orientation',
            data: {
                ...filteredOrientation,
                heading: heading
            },
            timestamp: timestamp
        });

        // ذخیره آخرین داده‌های جهت  
        this.lastOrientation = {
            ...filteredOrientation,
            heading: heading,
            timestamp: timestamp
        };
    }

    /**  
     * پردازش داده‌های GPS  
     * @param {Object} position موقعیت GPS {lat, lng}  
     * @param {number} accuracy دقت موقعیت (متر)  
     * @param {number} timestamp زمان دریافت داده  
     */
    processGpsData(position, accuracy = 5.0, timestamp = Date.now()) {
        if (!this.isActive) return;

        // لاگ داده‌های ورودی  
        this._logSensorData('gps', { ...position, accuracy }, timestamp);

        // اگر موقعیت مرجع تنظیم نشده است، آن را تنظیم کنید  
        if (!this.referencePosition) {
            console.log('Setting reference position from GPS:', position);

            this.referencePosition = {
                lat: position.lat,
                lng: position.lng,
                accuracy: accuracy,
                timestamp: timestamp
            };

            // ثبت نقطه اول در مسیر نسبی و جغرافیایی  
            this.path.push({ x: 0, y: 0, timestamp: timestamp });
            this.geoPath.push({ lat: position.lat, lng: position.lng, timestamp: timestamp });

            // مقداردهی مجدد موقعیت نسبی  
            this.currentPosition = { x: 0, y: 0, theta: this.currentPosition.theta };

            // اگر کالیبراسیون فعال است، آن را حفظ کنید  
            if (this.isCalibrating) {
                // تنظیم مجدد فیلتر کالمن با موقعیت اولیه  
                this.kalmanFilter.initialize({
                    x: 0,
                    y: 0,
                    theta: this._initialHeading || 0,
                    v: 0,
                    w: 0,
                    stride: this.strideLength,
                    timestamp: timestamp
                });
            }

            // اطلاع‌رسانی به لیستنرها  
            this._notify({
                type: 'referencePositionSet',
                referencePosition: this.referencePosition,
                kalmanState: this.kalmanFilter.getState(),
                path: this.path,
                geoPath: this.geoPath
            });

            return;
        }

        // تبدیل موقعیت GPS جدید به مختصات نسبی از نقطه مرجع  
        const relativePosition = this._calculateRelativePositionFromLatLng(
            this.referencePosition.lat,
            this.referencePosition.lng,
            position.lat,
            position.lng
        );

        // به‌روزرسانی فیلتر کالمن با اندازه‌گیری GPS جدید  
        this.kalmanFilter.update(
            {
                x_gps: relativePosition.x,
                y_gps: relativePosition.y,
                heading: this.lastOrientation ? this.lastOrientation.heading : undefined
            },
            {
                gps_accuracy: accuracy,
                heading_accuracy: this.lastOrientation ? 0.1 : undefined
            }
        );

        // گرفتن وضعیت به‌روز شده از فیلتر کالمن  
        const kalmanState = this.kalmanFilter.getState();

        // به‌روزرسانی موقعیت نسبی فعلی  
        this.currentPosition = {
            x: kalmanState.x,
            y: kalmanState.y,
            theta: kalmanState.theta
        };

        // تبدیل موقعیت نسبی فعلی به مختصات جغرافیایی  
        const currentGeoPosition = this._calculateNewLatLng(
            this.referencePosition.lat,
            this.referencePosition.lng,
            this.currentPosition.x,
            this.currentPosition.y
        );

        // افزودن به مسیر اگر فاصله کافی از آخرین نقطه دارد  
        if (this.path.length === 0 || this._calculateDistance(
            this.path[this.path.length - 1].x,
            this.path[this.path.length - 1].y,
            this.currentPosition.x,
            this.currentPosition.y
        ) > 0.5) { // حداقل 0.5 متر فاصله برای ثبت نقطه جدید در مسیر  
            this.path.push({
                x: this.currentPosition.x,
                y: this.currentPosition.y,
                timestamp: timestamp
            });

            this.geoPath.push({
                lat: currentGeoPosition.lat,
                lng: currentGeoPosition.lng,
                timestamp: timestamp
            });
        }

        // ذخیره آخرین داده‌های GPS  
        this.lastGps = {
            ...position,
            accuracy: accuracy,
            timestamp: timestamp
        };

        // اطلاع‌رسانی به لیستنرها  
        this._notify({
            type: 'positionUpdated',
            currentPosition: this.currentPosition,
            geoPosition: currentGeoPosition,
            kalmanState: kalmanState,
            path: this.path,
            geoPath: this.geoPath,
            source: 'gps'
        });
    }

    /**  
     * افزودن لیستنر برای دریافت تغییرات  
     * @param {Function} callback تابع اطلاع‌رسانی  
     * @returns {Function} تابع حذف لیستنر  
     */
    addListener(callback) {
        if (typeof callback === 'function') {
            this._listeners.push(callback);

            // ارسال وضعیت فعلی به لیستنر جدید  
            callback({
                type: 'initialState',
                isActive: this.isActive,
                isCalibrating: this.isCalibrating,
                stepCount: this.stepCount,
                strideLength: this.strideLength,
                kalmanState: this.kalmanFilter.getState(),
                path: this.path,
                geoPath: this.geoPath,
                referencePosition: this.referencePosition
            });

            // برگرداندن تابع حذف لیستنر  
            return () => {
                this._listeners = this._listeners.filter(listener => listener !== callback);
            };
        }

        return () => { }; // تابع خالی اگر callback معتبر نیست  
    }

    /**  
     * خروجی گرفتن از لاگ‌های ثبت شده  
     * @returns {Object} خروجی لاگ‌های ثبت شده  
     */
    exportLog() {
        const log = {
            timestamp: new Date().toISOString(),
            data: {
                sensorLog: this._log,
                path: this.path,
                geoPath: this.geoPath,
                stepCount: this.stepCount,
                strideLength: this.strideLength
            }
        };

        // ساخت یک بلاب برای دانلود  
        const blob = new Blob([JSON.stringify(log, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);

        // ایجاد لینک دانلود و کلیک خودکار  
        const a = document.createElement('a');
        a.href = url;
        a.download = `dead-reckoning-log-${new Date().toISOString().slice(0, 19).replace(/:/g, '-')}.json`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);

        console.log('Log exported:', log);
        return log;
    }

    /**  
* تبدیل موقعیت نسبی به مختصات جغرافیایی  
* @param {number} refLat عرض جغرافیایی نقطه مرجع  
* @param {number} refLng طول جغرافیایی نقطه مرجع  
* @param {number} x موقعیت نسبی x (متر)  
* @param {number} y موقعیت نسبی y (متر)  
* @returns {Object} مختصات جغرافیایی {lat, lng}  
*/
    _calculateNewLatLng(refLat, refLng, x, y) {
        // اطمینان از معتبر بودن مقادیر ورودی  
        if (isNaN(refLat) || isNaN(refLng) || isNaN(x) || isNaN(y)) {
            console.error('Invalid inputs in _calculateNewLatLng:', { refLat, refLng, x, y });
            return { lat: refLat || 0, lng: refLng || 0 }; // برگرداندن مقدار پیش‌فرض  
        }

        // شعاع زمین (متر)  
        const R = 6378137;

        // تبدیل درجه به رادیان  
        const lat1 = refLat * Math.PI / 180;
        const lng1 = refLng * Math.PI / 180;

        // محاسبه تغییر عرض و طول جغرافیایی  
        const dlat = y / R;
        const dlng = x / (R * Math.cos(lat1));

        // تبدیل رادیان به درجه و محاسبه مختصات جدید  
        const newLat = refLat + (dlat * 180 / Math.PI);
        const newLng = refLng + (dlng * 180 / Math.PI);

        // بررسی معتبر بودن نتایج  
        if (isNaN(newLat) || isNaN(newLng)) {
            console.error('Invalid result in _calculateNewLatLng:', { newLat, newLng, inputs: { refLat, refLng, x, y } });
            return { lat: refLat, lng: refLng }; // برگرداندن نقطه مرجع  
        }

        return { lat: newLat, lng: newLng };
    }

    /**  
     * تبدیل مختصات جغرافیایی به موقعیت نسبی  
     * @param {number} refLat عرض جغرافیایی نقطه مرجع  
     * @param {number} refLng طول جغرافیایی نقطه مرجع  
     * @param {number} lat عرض جغرافیایی نقطه جدید  
     * @param {number} lng طول جغرافیایی نقطه جدید  
     * @returns {Object} موقعیت نسبی {x, y} (متر)  
     */
    _calculateRelativePositionFromLatLng(refLat, refLng, lat, lng) {
        // شعاع زمین (متر)  
        const R = 6378137;

        // تبدیل درجه به رادیان  
        const lat1 = refLat * Math.PI / 180;
        const lng1 = refLng * Math.PI / 180;
        const lat2 = lat * Math.PI / 180;
        const lng2 = lng * Math.PI / 180;

        // محاسبه تغییر عرض و طول جغرافیایی  
        const dlat = lat2 - lat1;
        const dlng = lng2 - lng1;

        // محاسبه فاصله  
        const y = dlat * R;
        const x = dlng * R * Math.cos(lat1);

        return { x, y };
    }

    /**  
       /**  
 * محاسبه فاصله اقلیدسی بین دو نقطه  
 * @param {number} x1 مختصات x نقطه اول  
 * @param {number} y1 مختصات y نقطه اول  
 * @param {number} x2 مختصات x نقطه دوم  
 * @param {number} y2 مختصات y نقطه دوم  
 * @returns {number} فاصله (متر)  
 */
    _calculateDistance(x1, y1, x2, y2) {
        return Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
    }

    /**  
     * فیلتر کردن داده‌های شتاب‌سنج  
     * @param {Object} accelerometer داده‌های شتاب‌سنج  
     * @returns {Object} داده‌های فیلتر شده  
     */
    _filterAccelerometerData(accelerometer) {
        // استفاده از فیلتر پایین‌گذر برای حذف نویز  
        const filteredX = this.accelerometerLowPassFilter.filter(accelerometer.x, 'x');
        const filteredY = this.accelerometerLowPassFilter.filter(accelerometer.y, 'y');
        const filteredZ = this.accelerometerLowPassFilter.filter(accelerometer.z, 'z');

        // اگر در حال کالیبراسیون هستیم، بایاس شتاب‌سنج را به‌روز کنید  
        if (this.isCalibrating) {
            const weight = 0.1; // وزن به‌روزرسانی بایاس (0 تا 1)  
            this.accelerometerBias.x = (1 - weight) * this.accelerometerBias.x + weight * filteredX;
            this.accelerometerBias.y = (1 - weight) * this.accelerometerBias.y + weight * filteredY;
            this.accelerometerBias.z = (1 - weight) * this.accelerometerBias.z + weight * filteredZ;
        }

        // حذف بایاس از داده‌های فیلتر شده  
        const correctedX = filteredX - this.accelerometerBias.x;
        const correctedY = filteredY - this.accelerometerBias.y;
        const correctedZ = filteredZ - this.accelerometerBias.z;

        // اگر شتاب شامل جاذبه است (accelerationIncludingGravity)، مقدار شتاب جاذبه را حذف کنید  
        if (accelerometer.includesGravity) {
            // استفاده از فیلتر بالاگذر برای حذف تقریبی شتاب جاذبه  
            const highPassX = this.accelerometerHighPassFilter.filter(correctedX, 'x');
            const highPassY = this.accelerometerHighPassFilter.filter(correctedY, 'y');
            const highPassZ = this.accelerometerHighPassFilter.filter(correctedZ, 'z');

            return {
                x: highPassX,
                y: highPassY,
                z: highPassZ
            };
        }

        return {
            x: correctedX,
            y: correctedY,
            z: correctedZ
        };
    }

    /**  
     * فیلتر کردن داده‌های ژیروسکوپ  
     * @param {Object} gyroscope داده‌های ژیروسکوپ  
     * @returns {Object} داده‌های فیلتر شده  
     */
    _filterGyroscopeData(gyroscope) {
        // استفاده از فیلتر پایین‌گذر برای حذف نویز  
        const filteredAlpha = this.gyroscopeLowPassFilter.filter(gyroscope.alpha, 'alpha');
        const filteredBeta = this.gyroscopeLowPassFilter.filter(gyroscope.beta, 'beta');
        const filteredGamma = this.gyroscopeLowPassFilter.filter(gyroscope.gamma, 'gamma');

        // اگر در حال کالیبراسیون هستیم، بایاس ژیروسکوپ را به‌روز کنید  
        if (this.isCalibrating) {
            const weight = 0.1; // وزن به‌روزرسانی بایاس (0 تا 1)  
            this.gyroscopeBias.alpha = (1 - weight) * this.gyroscopeBias.alpha + weight * filteredAlpha;
            this.gyroscopeBias.beta = (1 - weight) * this.gyroscopeBias.beta + weight * filteredBeta;
            this.gyroscopeBias.gamma = (1 - weight) * this.gyroscopeBias.gamma + weight * filteredGamma;
        }

        // حذف بایاس از داده‌های فیلتر شده  
        const correctedAlpha = filteredAlpha - this.gyroscopeBias.alpha;
        const correctedBeta = filteredBeta - this.gyroscopeBias.beta;
        const correctedGamma = filteredGamma - this.gyroscopeBias.gamma;

        // تبدیل از درجه به رادیان  
        const alphaDeg = correctedAlpha;
        const betaDeg = correctedBeta;
        const gammaDeg = correctedGamma;

        // سرعت‌های زاویه‌ای (رادیان بر ثانیه)  
        const alphaRad = (alphaDeg * Math.PI) / 180;
        const betaRad = (betaDeg * Math.PI) / 180;
        const gammaRad = (gammaDeg * Math.PI) / 180;

        return {
            alpha: alphaDeg,
            beta: betaDeg,
            gamma: gammaDeg,
            alphaRad: alphaRad,
            betaRad: betaRad,
            gammaRad: gammaRad
        };
    }

    /**  
     * فیلتر کردن داده‌های جهت  
     * @param {Object} orientation داده‌های جهت  
     * @returns {Object} داده‌های فیلتر شده  
     */
    _filterOrientationData(orientation) {
        // استفاده از فیلتر پایین‌گذر برای حذف نویز  
        const filteredAlpha = this.orientationLowPassFilter.filter(orientation.alpha, 'alpha');
        const filteredBeta = this.orientationLowPassFilter.filter(orientation.beta, 'beta');
        const filteredGamma = this.orientationLowPassFilter.filter(orientation.gamma, 'gamma');

        return {
            alpha: filteredAlpha,
            beta: filteredBeta,
            gamma: filteredGamma,
            absolute: orientation.absolute
        };
    }

    /**  
     * تشخیص گام با استفاده از الگوریتم تشخیص پیک  
     * @param {number} accelNorm نُرم شتاب  
     * @param {number} timestamp زمان دریافت داده  
     * @returns {boolean} آیا گام تشخیص داده شده است  
     */
    _detectStep(accelNorm, timestamp) {
        // اگر کالیبراسیون فعال است، گام تشخیص داده نشود  
        if (this.isCalibrating) return false;

        // تشخیص پیک با استفاده از کلاس PeakDetector  
        const peakDetected = this.peakDetector.addSample(accelNorm, timestamp);

        if (peakDetected) {
            // محاسبه فاصله زمانی از آخرین گام  
            const timeSinceLastStep = timestamp - this.lastStepTime;

            // بررسی شرایط مناسب برای تشخیص گام:  
            // 1. حداقل 250 میلی‌ثانیه از آخرین گام گذشته باشد (حداکثر 4 گام در ثانیه)  
            // 2. بزرگی شتاب بزرگتر از آستانه باشد  
            if (timeSinceLastStep > 10 && accelNorm > 1.2) {
                this.stepCount++;
                this.lastStepTime = timestamp;

                // اطلاع‌رسانی به لیستنرها  
                this._notify({
                    type: 'stepDetected',
                    stepCount: this.stepCount,
                    timestamp: timestamp
                });

                return true;
            }
        }

        return false;
    }

    /**  
     * پردازش داده‌های سنسور و به‌روزرسانی موقعیت  
     * @param {Object} data داده‌های پردازش شده  
     */
    _processSensorData(data) {
        // در ابتدا بررسی کنید آیا کالیبراسیون به اتمام رسیده است  
        if (this.isCalibrating) {
            const now = Date.now();
            if (now - this.calibrationStart > this.calibrationDuration) {
                console.log('Calibration complete. Biases:', {
                    accelerometer: this.accelerometerBias,
                    gyroscope: this.gyroscopeBias
                });

                this.isCalibrating = false;

                // اطلاع‌رسانی به لیستنرها  
                this._notify({
                    type: 'calibrationComplete',
                    isCalibrating: false,
                    accelerometerBias: this.accelerometerBias,
                    gyroscopeBias: this.gyroscopeBias
                });
            }
            return; // در طول کالیبراسیون، موقعیت به‌روز نشود  
        }

        // محاسبه فاصله زمانی از آخرین به‌روزرسانی  
        const now = data.timestamp;
        const dt = (now - this.lastUpdateTime) / 1000; // تبدیل به ثانیه  

        // اگر اولین داده است یا dt منفی است، فقط زمان را به‌روز کنید  
        if (this.lastUpdateTime === 0 || dt <= 0) {
            this.lastUpdateTime = now;
            return;
        }

        // آماده‌سازی ورودی‌های کنترل برای فیلتر کالمن  
        let controlInputs = { a_norm: 0, omega: 0 };

        // بروزرسانی سرعت زاویه‌ای از ژیروسکوپ  
        if (data.type === 'gyroscope') {
            // در اینجا ما از سرعت زاویه‌ای حول محور z (alpha) استفاده می‌کنیم  
            controlInputs.omega = data.data.alphaRad || 0;
        }

        // بروزرسانی فعالیت/گام از شتاب‌سنج  
        if (data.type === 'accelerometer' && data.stepDetected) {
            controlInputs.a_norm = 1; // گام تشخیص داده شده  
        }

        // پیش‌بینی موقعیت با فیلتر کالمن  
        this.kalmanFilter.predict(controlInputs, now);

        // به‌روزرسانی موقعیت نسبی فعلی از فیلتر کالمن  
        const kalmanState = this.kalmanFilter.getState();
        this.currentPosition = {
            x: kalmanState.x,
            y: kalmanState.y,
            theta: kalmanState.theta
        };

        // اگر نقطه مرجع تنظیم شده است، موقعیت جغرافیایی فعلی را محاسبه کنید  
        let currentGeoPosition = null;
        if (this.referencePosition) {
            currentGeoPosition = this._calculateNewLatLng(
                this.referencePosition.lat,
                this.referencePosition.lng,
                this.currentPosition.x,
                this.currentPosition.y
            );

            // افزودن به مسیر اگر فاصله کافی از آخرین نقطه دارد  
            if (this.path.length === 0 || (
                this._calculateDistance(
                    this.path[this.path.length - 1].x,
                    this.path[this.path.length - 1].y,
                    this.currentPosition.x,
                    this.currentPosition.y
                ) > 0.5 && // حداقل 0.5 متر فاصله  
                now - this.path[this.path.length - 1].timestamp > 500 // حداقل 500 میلی‌ثانیه فاصله زمانی  
            )) {
                this.path.push({
                    x: this.currentPosition.x,
                    y: this.currentPosition.y,
                    timestamp: now
                });

                this.geoPath.push({
                    lat: currentGeoPosition.lat,
                    lng: currentGeoPosition.lng,
                    timestamp: now
                });
            }
        }

        // به‌روزرسانی زمان آخرین پردازش  
        this.lastUpdateTime = now;

        // اطلاع‌رسانی به لیستنرها (فقط اگر تغییر قابل توجهی رخ داده باشد یا اندازه‌گیری ورودی داشته باشیم)  
        if (data.type === 'accelerometer' && data.stepDetected) {
            this._notify({
                type: 'positionUpdated',
                currentPosition: this.currentPosition,
                geoPosition: currentGeoPosition,
                kalmanState: kalmanState,
                path: this.path,
                geoPath: this.geoPath,
                source: 'imu'
            });
        } else if (data.type === 'orientation') {
            this._notify({
                type: 'orientationUpdated',
                currentPosition: this.currentPosition,
                geoPosition: currentGeoPosition,
                kalmanState: kalmanState,
                source: 'imu'
            });
        }
    }

    /**  
       /**  
     * اطلاع‌رسانی به لیستنرها  
     * @param {Object} data داده‌های اطلاع‌رسانی  
     * @private  
     */
    _notify(data) {
        // افزودن isActive و isCalibrating به همه اطلاع‌رسانی‌ها  
        const eventData = {
            ...data,
            isActive: this.isActive,
            isCalibrating: this.isCalibrating
        };

        // صدا زدن همه لیستنرها  
        this._listeners.forEach(listener => {
            try {
                listener(eventData);
            } catch (error) {
                console.error('Error in Dead Reckoning listener:', error);
            }
        });
    }

    /**  
     * ثبت داده‌های سنسور در لاگ  
     * @param {string} sensorType نوع سنسور  
     * @param {Object} data داده‌های سنسور  
     * @param {number} timestamp زمان دریافت داده  
     * @private  
     */
    _logSensorData(sensorType, data, timestamp) {
        // محدود کردن حجم لاگ برای جلوگیری از مصرف زیاد حافظه  
        const maxLogSize = 1000; // حداکثر تعداد رکوردها در لاگ  

        if (this._log.timestamp.length >= maxLogSize) {
            // حذف قدیمی‌ترین رکوردها  
            this._log.timestamp.shift();
            this._log.sensor.shift();
            this._log.data.shift();
            this._log.result.shift();
        }

        // افزودن رکورد جدید  
        this._log.timestamp.push(timestamp);
        this._log.sensor.push(sensorType);
        this._log.data.push(JSON.parse(JSON.stringify(data))); // کلون کردن داده برای جلوگیری از تغییرات بعدی  

        // ثبت نتایج (موقعیت فعلی، وضعیت کالمن و غیره)  
        const result = {
            position: this.currentPosition ? { ...this.currentPosition } : null,
            kalmanState: this.kalmanFilter ? this.kalmanFilter.getState() : null,
            stepCount: this.stepCount
        };
        this._log.result.push(result);
    }
}

// ایجاد سینگلتون  
const advancedDeadReckoningService = new AdvancedDeadReckoningService();
export default advancedDeadReckoningService;  ```   
   
## \src\services\KalmanFilter.js   
```javascript   
/**  
 * پیاده‌سازی Extended Kalman Filter برای تخمین موقعیت با ترکیب سنسورها  
 */  
export class KalmanFilter {  
    constructor(options = {}) {  
      // تنظیمات ابعاد فیلتر کالمن  
      this.stateSize = options.stateSize || 6;       // [x, y, theta, v, w, stride]  
      this.measurementSize = options.measurementSize || 3; // [x_gps, y_gps, heading]  
      this.controlSize = options.controlSize || 2;   // [a_norm, omega]  
      
      // بردار وضعیت - مقادیر پیش‌فرض  
      this.x = new Array(this.stateSize).fill(0);  
      
      // ماتریس کوواریانس وضعیت - شروع با مقادیر بزرگ در قطر اصلی  
      this.P = new Array(this.stateSize * this.stateSize).fill(0);  
      for (let i = 0; i < this.stateSize; i++) {  
        this.P[i * this.stateSize + i] = i < 2 ? 50.0 : 1.0; // عدم قطعیت بیشتر برای موقعیت اولیه  
      }  
      
      // ماتریس نویز فرآیند (Q) - میزان عدم قطعیت در مدل سیستم  
      this.Q = new Array(this.stateSize * this.stateSize).fill(0);  
      for (let i = 0; i < this.stateSize; i++) {  
        this.Q[i * this.stateSize + i] = 0.01; // مقادیر کوچکتر = اعتماد بیشتر به مدل  
      }  
      // عدم قطعیت بیشتر برای موقعیت و جهت  
      this.Q[0 * this.stateSize + 0] = 0.1;  // x  
      this.Q[1 * this.stateSize + 1] = 0.1;  // y  
      this.Q[2 * this.stateSize + 2] = 0.1;  // theta  
      
      // ماتریس نویز اندازه‌گیری (R) - میزان عدم قطعیت در داده‌های حسگر  
      this.R = new Array(this.measurementSize * this.measurementSize).fill(0);  
      this.R[0 * this.measurementSize + 0] = 5.0;  // x_gps (متر مربع)  
      this.R[1 * this.measurementSize + 1] = 5.0;  // y_gps (متر مربع)  
      this.R[2 * this.measurementSize + 2] = 0.1;  // heading (رادیان مربع)  
      
      // ضریب میرایی برای کاهش سرعت و چرخش در صورت نبود ورودی  
      this.timeDecay = 0.95; // 5% کاهش در هر گام زمانی  
      
      // متغیرهای داخلی  
      this.lastUpdateTime = 0;  
    }  
    
    /**  
     * مقداردهی اولیه فیلتر با وضعیت اولیه  
     * @param {Object} initialState وضعیت اولیه {x, y, theta, v, w, stride, timestamp}  
     */  
    initialize(initialState) {  
      // محافظت در برابر مقادیر نامعتبر  
      initialState = initialState || {};  
      
      // تنظیم وضعیت اولیه  
      this.x[0] = this._validateNumber(initialState.x, 0);  
      this.x[1] = this._validateNumber(initialState.y, 0);  
      this.x[2] = this._validateNumber(initialState.theta, 0);  
      this.x[3] = this._validateNumber(initialState.v, 0);  
      this.x[4] = this._validateNumber(initialState.w, 0);  
      this.x[5] = this._validateNumber(initialState.stride, 0.75);  
      
      // تنظیم زمان آخرین به‌روزرسانی  
      this.lastUpdateTime = initialState.timestamp || Date.now();  
      
      // بازنشانی ماتریس P (عدم قطعیت اولیه)  
      this.P = new Array(this.stateSize * this.stateSize).fill(0);  
      for (let i = 0; i < this.stateSize; i++) {  
        this.P[i * this.stateSize + i] = i < 2 ? 50.0 : 1.0;  
      }  
      
      console.log("Kalman filter initialized:", this.getState());  
    }  
    
    /**  
     * تنظیم طول گام (استراید)  
     * @param {number} strideLength طول گام (متر)  
     */  
    setStrideLength(strideLength) {  
      if (strideLength > 0) {  
        this.x[5] = strideLength;  
      }  
    }  
    
    /**  
     * مرحله پیش‌بینی فیلتر کالمن با استفاده از مدل سیستم  
     * @param {Object} u بردار ورودی کنترل {a_norm, omega}  
     * @param {number} timestamp زمان فعلی (میلی‌ثانیه)  
     */  
    predict(u = {}, timestamp = Date.now()) {  
      // محاسبه گام زمانی (به ثانیه)  
      const dt = Math.min(Math.max(0, (timestamp - this.lastUpdateTime) / 1000.0), 0.2);  
      
      // اگر گام زمانی خیلی کوچک است، از پیش‌بینی صرف‌نظر کنید یا زمان کوچکتر از 0.01 ثانیه است، فقط زمان را به‌روز کنید  
      if (dt < 0.01) {  
        this.lastUpdateTime = timestamp;  
        return;  
      }  
      
      // اگر ورودی کنترل وجود ندارد، با مقادیر پیش‌فرض کار کنید  
      const a_norm = u.a_norm || 0;  // تشخیص گام (0 یا 1)  
      const omega = u.omega || 0;    // سرعت زاویه‌ای (رادیان بر ثانیه)  
      
      // قابلیت ردیابی: اطمینان از عدم وجود مقادیر NaN  
      if (isNaN(a_norm) || isNaN(omega)) {  
        console.warn('مقادیر نامعتبر در ورودی کنترل فیلتر کالمن:', u);  
        this.lastUpdateTime = timestamp;  
        return;  
      }  
      
      // اعمال ضریب میرایی اگر ورودی شتاب وجود ندارد  
      // موقعیت v = سرعت خطی  
      let velocity = this.x[3];  
      if (a_norm <= 0) {  
        velocity *= this.timeDecay; // کاهش سرعت اگر گامی تشخیص داده نشده  
      } else {  
        // تشخیص گام - محاسبه سرعت با استفاده از طول گام  
        const strideLength = this.x[5];  
        velocity = strideLength / 0.5; // فرض: طول گام در 0.5 ثانیه پیموده می‌شود  
      }  
      
      // سرعت زاویه‌ای w  
      let angularVelocity = omega;  
      if (Math.abs(omega) < 0.001) {  
        // اگر ورودی چرخش نزدیک به صفر است، از مقدار فعلی با میرایی استفاده کنید  
        angularVelocity = this.x[4] * this.timeDecay;  
      }  
      
      // به‌روزرسانی بردار وضعیت (x) با استفاده از مدل حرکت غیرهولونومیک  
      // x_k+1 = x_k + v * dt * cos(theta)  
      // y_k+1 = y_k + v * dt * sin(theta)  
      // theta_k+1 = theta_k + w * dt  
      // v_k+1 = v (یا با میرایی)  
      // w_k+1 = w (یا با میرایی)  
      const theta = this._normalizeDegree(this.x[2]);  
      
      // به‌روزرسانی موقعیت  
      this.x[0] += velocity * dt * Math.cos(theta);  // x  
      this.x[1] += velocity * dt * Math.sin(theta);  // y  
      this.x[2] = this._normalizeDegree(theta + angularVelocity * dt);  // theta  
      this.x[3] = velocity;  // v  
      this.x[4] = angularVelocity;  // w  
      
      // به‌روزرسانی ماتریس P با استفاده از ژاکوبین تقریبی مدل سیستم  
      // برای سادگی، فقط Q را به P اضافه می‌کنیم  
      // P = F*P*F' + Q (در اینجا ساده‌سازی شده است)  
      for (let i = 0; i < this.stateSize; i++) {  
        for (let j = 0; j < this.stateSize; j++) {  
          this.P[i * this.stateSize + j] += this.Q[i * this.stateSize + j] * dt;  
        }  
      }  
      
      // یک افزایش کوچک در عدم قطعیت موقعیت و جهت با گذشت زمان  
      this.P[0 * this.stateSize + 0] += dt * velocity * 0.1; // افزایش عدم قطعیت در x  
      this.P[1 * this.stateSize + 1] += dt * velocity * 0.1; // افزایش عدم قطعیت در y  
      this.P[2 * this.stateSize + 2] += dt * Math.abs(angularVelocity) * 0.1; // افزایش عدم قطعیت در theta  
      
      // به‌روزرسانی زمان آخرین پیش‌بینی  
      this.lastUpdateTime = timestamp;  
    }  
    
    /**  
     * مرحله به‌روزرسانی فیلتر کالمن با استفاده از اندازه‌گیری‌ها  
     * @param {Object} z بردار اندازه‌گیری {x_gps, y_gps, heading}  
     * @param {Object} uncertainties عدم قطعیت‌های اندازه‌گیری {gps_accuracy, heading_accuracy}  
     */  
    update(z = {}, uncertainties = {}) {  
      // اگر هیچ داده اندازه‌گیری وجود ندارد، کاری انجام ندهید  
      if (Object.keys(z).length === 0) {  
        return;  
      }  
      
      // اطمینان از معتبر بودن مقادیر اندازه‌گیری  
      if ((z.x_gps !== undefined && isNaN(z.x_gps)) ||   
          (z.y_gps !== undefined && isNaN(z.y_gps)) ||   
          (z.heading !== undefined && isNaN(z.heading))) {  
        console.warn('مقادیر نامعتبر در اندازه‌گیری:', z);  
        return;  
      }  
      
      // تنظیم ماتریس نویز اندازه‌گیری (R) بر اساس دقت GPS  
      if (uncertainties.gps_accuracy !== undefined && !isNaN(uncertainties.gps_accuracy)) {  
        // مقدار بزرگتر دقت = نویز بیشتر = اعتماد کمتر به GPS  
        const gpsVariance = Math.pow(Math.max(1.0, uncertainties.gps_accuracy), 2);  
        this.R[0 * this.measurementSize + 0] = gpsVariance;  
        this.R[1 * this.measurementSize + 1] = gpsVariance;  
      }  
      
      if (uncertainties.heading_accuracy !== undefined && !isNaN(uncertainties.heading_accuracy)) {  
        this.R[2 * this.measurementSize + 2] = uncertainties.heading_accuracy;  
      }  
      
      // ساخت بردار اندازه‌گیری و ماتریس H (ژاکوبین اندازه‌گیری)  
      const measurement = [0, 0, 0]; // مقادیر پیش‌فرض  
      const H = new Array(this.measurementSize * this.stateSize).fill(0);  
      
      // بردار نوآوری (تفاوت بین اندازه‌گیری و پیش‌بینی)  
      const innovation = new Array(this.measurementSize).fill(0);  
      
      // بررسی موقعیت GPS  
      if (z.x_gps !== undefined && z.y_gps !== undefined) {  
        measurement[0] = z.x_gps;  
        measurement[1] = z.y_gps;  
        
        // ماتریس H برای GPS (ارتباط مستقیم با x و y)  
        H[0 * this.stateSize + 0] = 1; // H[0,0] = 1 (مشاهده x)  
        H[1 * this.stateSize + 1] = 1; // H[1,1] = 1 (مشاهده y)  
        
        // محاسبه نوآوری  
        innovation[0] = z.x_gps - this.x[0];  
        innovation[1] = z.y_gps - this.x[1];  
      }  
      
    // بررسی جهت (مگنتومتر/قطب‌نما)  
    if (z.heading !== undefined) {  
        measurement[2] = this._normalizeDegree(z.heading);  
        
        // ماتریس H برای جهت (ارتباط مستقیم با theta)  
        H[2 * this.stateSize + 2] = 1; // H[2,2] = 1 (مشاهده theta)  
        
        // محاسبه نوآوری با توجه به طبیعت دایره‌ای زاویه  
        let headingDiff = z.heading - this.x[2];  
        // نرمال‌سازی تفاوت به محدوده [-pi, pi]  
        while (headingDiff > Math.PI) headingDiff -= 2 * Math.PI;  
        while (headingDiff < -Math.PI) headingDiff += 2 * Math.PI;  
        innovation[2] = headingDiff;  
      }  
      
      // محاسبه S = H*P*H' + R (ماتریس کوواریانس نوآوری)  
      const S = new Array(this.measurementSize * this.measurementSize).fill(0);  
      for (let i = 0; i < this.measurementSize; i++) {  
        for (let j = 0; j < this.measurementSize; j++) {  
          // مقدار اولیه از R  
          S[i * this.measurementSize + j] = this.R[i * this.measurementSize + j];  
          
          // اضافه کردن H*P*H'  
          for (let k = 0; k < this.stateSize; k++) {  
            for (let l = 0; l < this.stateSize; l++) {  
              S[i * this.measurementSize + j] += H[i * this.stateSize + k] *   
                                              this.P[k * this.stateSize + l] *   
                                              H[j * this.stateSize + l];  
            }  
          }  
        }  
      }  
      
      // محاسبه K = P*H'*S^(-1) (بهره کالمن)  
      // برای سادگی، محاسبه S^(-1) را به صورت عناصر قطری انجام می‌دهیم  
      const K = new Array(this.stateSize * this.measurementSize).fill(0);  
      for (let i = 0; i < this.stateSize; i++) {  
        for (let j = 0; j < this.measurementSize; j++) {  
          for (let k = 0; k < this.stateSize; k++) {  
            // در این ساده‌سازی، فقط عناصر قطری S را در نظر می‌گیریم  
            if (S[j * this.measurementSize + j] > 0.0001) {  
              K[i * this.measurementSize + j] += this.P[i * this.stateSize + k] *   
                                              H[j * this.stateSize + k] /   
                                              S[j * this.measurementSize + j];  
            }  
          }  
        }  
      }  
      
      // به‌روزرسانی بردار وضعیت: x = x + K*innovation  
      for (let i = 0; i < this.stateSize; i++) {  
        for (let j = 0; j < this.measurementSize; j++) {  
          this.x[i] += K[i * this.measurementSize + j] * innovation[j];  
        }  
      }  
      
      // نرمال‌سازی زاویه theta به محدوده [0, 2*pi]  
      this.x[2] = this._normalizeDegree(this.x[2]);  
      
      // به‌روزرسانی ماتریس کوواریانس: P = (I - K*H)*P  
      const newP = new Array(this.stateSize * this.stateSize).fill(0);  
      for (let i = 0; i < this.stateSize; i++) {  
        for (let j = 0; j < this.stateSize; j++) {  
          // ابتدا I (ماتریس همانی)  
          newP[i * this.stateSize + j] = (i === j) ? 1 : 0;  
          
          // سپس کم کردن K*H  
          for (let k = 0; k < this.measurementSize; k++) {  
            newP[i * this.stateSize + j] -= K[i * this.measurementSize + k] *   
                                         H[k * this.stateSize + j];  
          }  
        }  
      }  
      
      // P = newP * P  
      const tempP = [...this.P];  
      for (let i = 0; i < this.stateSize; i++) {  
        for (let j = 0; j < this.stateSize; j++) {  
          this.P[i * this.stateSize + j] = 0;  
          for (let k = 0; k < this.stateSize; k++) {  
            this.P[i * this.stateSize + j] += newP[i * this.stateSize + k] *   
                                           tempP[k * this.stateSize + j];  
          }  
        }  
      }  
    }  
    
    /**  
     * دریافت وضعیت فعلی فیلتر کالمن  
     * @returns {Object} وضعیت فعلی {x, y, theta, v, w, stride, timestamp}  
     */  
    getState() {  
      // اطمینان از معتبر بودن همه مقادیر  
      return {  
        x: this._validateNumber(this.x[0], 0),  
        y: this._validateNumber(this.x[1], 0),  
        theta: this._validateNumber(this.x[2], 0),  
        v: this._validateNumber(this.x[3], 0),  
        w: this._validateNumber(this.x[4], 0),  
        stride: this._validateNumber(this.x[5], 0.75),  
        timestamp: this.lastUpdateTime  
      };  
    }  
    
    /**  
     * نرمال‌سازی زاویه به محدوده [0, 2*pi]  
     * @param {number} angle زاویه (رادیان)  
     * @returns {number} زاویه نرمال‌شده  
     */  
    _normalizeDegree(angle) {  
      if (isNaN(angle)) return 0;  
      
      // نرمال‌سازی به محدوده [0, 2*pi]  
      while (angle < 0) angle += 2 * Math.PI;  
      while (angle >= 2 * Math.PI) angle -= 2 * Math.PI;  
      
      return angle;  
    }  
    
    /**  
     * تضمین یک مقدار عددی معتبر  
     * @param {number} value مقدار ورودی  
     * @param {number} defaultValue مقدار پیش‌فرض در صورت نامعتبر بودن  
     * @returns {number} مقدار معتبر  
     */  
    _validateNumber(value, defaultValue = 0) {  
      return (value !== undefined && !isNaN(value)) ? value : defaultValue;  
    }  
  }  
  
  export default KalmanFilter;  ```   
   
## \src\services\LogStorageService.js   
```javascript   
// src/services/LogStorageService.js  
export class LogStorageService {  
  static DB_NAME = 'gps_tracker_db';  
  static GPS_LOGS_STORE = 'gps_logs';  
  static TRACK_LOGS_STORE = 'track_logs';  
  
  static async initDB() {  
    return new Promise((resolve, reject) => {  
      const request = indexedDB.open(this.DB_NAME, 1);  
      
      request.onupgradeneeded = (event) => {  
        const db = event.target.result;  
        
        // ایجاد فروشگاه برای لاگ‌های GPS  
        if (!db.objectStoreNames.contains(this.GPS_LOGS_STORE)) {  
          const gpsStore = db.createObjectStore(this.GPS_LOGS_STORE, { keyPath: 'id', autoIncrement: true });  
          gpsStore.createIndex('timestamp', 'timestamp', { unique: false });  
        }  
        
        // ایجاد فروشگاه برای لاگ‌های مسیر  
        if (!db.objectStoreNames.contains(this.TRACK_LOGS_STORE)) {  
          const trackStore = db.createObjectStore(this.TRACK_LOGS_STORE, { keyPath: 'id', autoIncrement: true });  
          trackStore.createIndex('startTime', 'startTime', { unique: false });  
        }  
      };  
      
      request.onsuccess = (event) => {  
        resolve(event.target.result);  
      };  
      
      request.onerror = (event) => {  
        console.error('خطا در باز کردن دیتابیس:', event.target.error);  
        reject(event.target.error);  
      };  
    });  
  }  
  
  static async saveGPSLog(location, isNoisy = false) {  
    try {  
      const db = await this.initDB();  
      return new Promise((resolve, reject) => {  
        const transaction = db.transaction([this.GPS_LOGS_STORE], 'readwrite');  
        const store = transaction.objectStore(this.GPS_LOGS_STORE);  
        
        const log = {  
          coords: location.coords,  
          timestamp: location.timestamp || Date.now(),  
          isNoisy,  
          deviceInfo: {  
            userAgent: navigator.userAgent,  
            platform: navigator.platform,  
            language: navigator.language,  
            connection: navigator.connection ? {  
              type: navigator.connection.type,  
              effectiveType: navigator.connection.effectiveType,  
              downlink: navigator.connection.downlink,  
              rtt: navigator.connection.rtt  
            } : null  
          },  
          logTime: new Date().toISOString()  
        };  
        
        const request = store.add(log);  
        
        request.onsuccess = () => {  
          resolve(request.result);  
        };  
        
        request.onerror = (event) => {  
          console.error('خطا در ذخیره لاگ GPS:', event.target.error);  
          reject(event.target.error);  
        };  
      });  
    } catch (err) {  
      console.error('خطا در ذخیره لاگ GPS:', err);  
      // فول‌بک به localStorage اگر IndexedDB کار نکرد  
      this.saveGPSLogToLocalStorage(location, isNoisy);  
    }  
  }  
  
  static saveGPSLogToLocalStorage(location, isNoisy = false) {  
    try {  
      const logs = JSON.parse(localStorage.getItem('gps_logs') || '[]');  
      logs.push({  
        coords: location.coords,  
        timestamp: location.timestamp || Date.now(),  
        isNoisy,  
        deviceInfo: {  
          userAgent: navigator.userAgent  
        },  
        logTime: new Date().toISOString()  
      });  
      
      // محدود کردن تعداد لاگ‌ها برای جلوگیری از پر شدن حافظه  
      if (logs.length > 10000) {  
        logs.splice(0, logs.length - 10000);  
      }  
      
      localStorage.setItem('gps_logs', JSON.stringify(logs));  
    } catch (err) {  
      console.error('خطا در ذخیره لاگ در localStorage:', err);  
    }  
  }  
  
  static async saveTrackLog(trackPoints, startTime, endTime, metadata = {}) {  
    try {  
      const db = await this.initDB();  
      return new Promise((resolve, reject) => {  
        const transaction = db.transaction([this.TRACK_LOGS_STORE], 'readwrite');  
        const store = transaction.objectStore(this.TRACK_LOGS_STORE);  
        
        const trackLog = {  
          points: trackPoints,  
          startTime,  
          endTime,  
          duration: endTime - startTime,  
          pointCount: trackPoints.length,  
          metadata: {  
            ...metadata,  
            deviceInfo: {  
              userAgent: navigator.userAgent,  
              platform: navigator.platform  
            }  
          },  
          createdAt: new Date().toISOString()  
        };  
        
        const request = store.add(trackLog);  
        
        request.onsuccess = () => {  
          resolve(request.result);  
        };  
        
        request.onerror = (event) => {  
          console.error('خطا در ذخیره لاگ مسیر:', event.target.error);  
          reject(event.target.error);  
        };  
      });  
    } catch (err) {  
      console.error('خطا در ذخیره لاگ مسیر:', err);  
      // فول‌بک به localStorage  
      this.saveTrackLogToLocalStorage(trackPoints, startTime, endTime, metadata);  
    }  
  }  
  
  static saveTrackLogToLocalStorage(trackPoints, startTime, endTime, metadata = {}) {  
    try {  
      const tracks = JSON.parse(localStorage.getItem('track_logs') || '[]');  
      tracks.push({  
        points: trackPoints,  
        startTime,  
        endTime,  
        duration: endTime - startTime,  
        pointCount: trackPoints.length,  
        metadata,  
        createdAt: new Date().toISOString()  
      });  
      
      // محدود کردن تعداد مسیرها  
      if (tracks.length > 100) {  
        tracks.splice(0, tracks.length - 100);  
      }  
      
      localStorage.setItem('track_logs', JSON.stringify(tracks));  
    } catch (err) {  
      console.error('خطا در ذخیره مسیر در localStorage:', err);  
    }  
  }  
  
  static async getGPSLogs(limit = 1000, offset = 0) {  
    try {  
      const db = await this.initDB();  
      return new Promise((resolve, reject) => {  
        const transaction = db.transaction([this.GPS_LOGS_STORE], 'readonly');  
        const store = transaction.objectStore(this.GPS_LOGS_STORE);  
        const index = store.index('timestamp');  
        
        const logs = [];  
        let cursorRequest = index.openCursor(null, 'prev'); // از جدیدترین به قدیمی‌ترین  
        let count = 0;  
        
        cursorRequest.onsuccess = (event) => {  
          const cursor = event.target.result;  
          if (cursor && count < offset + limit) {  
            if (count >= offset) {  
              logs.push(cursor.value);  
            }  
            count++;  
            cursor.continue();  
          } else {  
            resolve(logs);  
          }  
        };  
        
        cursorRequest.onerror = (event) => {  
          console.error('خطا در بازیابی لاگ‌های GPS:', event.target.error);  
          reject(event.target.error);  
        };  
      });  
    } catch (err) {  
      console.error('خطا در بازیابی لاگ‌های GPS:', err);  
      // فول‌بک به localStorage  
      const logs = JSON.parse(localStorage.getItem('gps_logs') || '[]');  
      return logs.slice(-Math.min(limit, logs.length));  
    }  
  }  
  
  static async getTrackLogs() {  
    try {  
      const db = await this.initDB();  
      return new Promise((resolve, reject) => {  
        const transaction = db.transaction([this.TRACK_LOGS_STORE], 'readonly');  
        const store = transaction.objectStore(this.TRACK_LOGS_STORE);  
        const index = store.index('startTime');  
        
        const request = index.getAll();  
        
        request.onsuccess = () => {  
          resolve(request.result);  
        };  
        
        request.onerror = (event) => {  
          console.error('خطا در بازیابی لاگ‌های مسیر:', event.target.error);  
          reject(event.target.error);  
        };  
      });  
    } catch (err) {  
      console.error('خطا در بازیابی لاگ‌های مسیر:', err);  
      // فول‌بک به localStorage  
      return JSON.parse(localStorage.getItem('track_logs') || '[]');  
    }  
  }  
  
  static async clearGPSLogs() {  
    try {  
      const db = await this.initDB();  
      return new Promise((resolve, reject) => {  
        const transaction = db.transaction([this.GPS_LOGS_STORE], 'readwrite');  
        const store = transaction.objectStore(this.GPS_LOGS_STORE);  
        
        const request = store.clear();  
        
        request.onsuccess = () => {  
          resolve(true);  
        };  
        
        request.onerror = (event) => {  
          console.error('خطا در پاک کردن لاگ‌های GPS:', event.target.error);  
          reject(event.target.error);  
        };  
      });  
    } catch (err) {  
      console.error('خطا در پاک کردن لاگ‌های GPS:', err);  
      localStorage.removeItem('gps_logs');  
      return true;  
    }  
  }  
  
  static async clearTrackLogs() {  
    try {  
      const db = await this.initDB();  
      return new Promise((resolve, reject) => {  
        const transaction = db.transaction([this.TRACK_LOGS_STORE], 'readwrite');  
        const store = transaction.objectStore(this.TRACK_LOGS_STORE);  
        
        const request = store.clear();  
        
        request.onsuccess = () => {  
          resolve(true);  
        };  
        
        request.onerror = (event) => {  
          console.error('خطا در پاک کردن لاگ‌های مسیر:', event.target.error);  
          reject(event.target.error);  
        };  
      });  
    } catch (err) {  
      console.error('خطا در پاک کردن لاگ‌های مسیر:', err);  
      localStorage.removeItem('track_logs');  
      return true;  
    }  
  }  
  
  static async exportGPSLogsAsJSON() {  
    const logs = await this.getGPSLogs(100000); // حداکثر 100،000 لاگ  
    return JSON.stringify(logs, null, 2);  
  }  
  
  static async exportGPSLogsAsCSV() {  
    const logs = await this.getGPSLogs(100000);  
    
    if (logs.length === 0) {  
      return 'هیچ لاگی یافت نشد';  
    }  
    
    // ایجاد هدرهای CSV  
    let csv = 'timestamp,latitude,longitude,accuracy,altitude,heading,speed,isNoisy\n';  
    
    // اضافه کردن داده‌ها  
    logs.forEach(log => {  
      const timestamp = new Date(log.timestamp).toISOString();  
      const lat = log.coords.lat || '';  
      const lng = log.coords.lng || '';  
      const accuracy = log.coords.accuracy || '';  
      const altitude = log.coords.altitude || '';  
      const heading = log.coords.heading || '';  
      const speed = log.coords.speed || '';  
      const isNoisy = log.isNoisy ? 'true' : 'false';  
      
      csv += `${timestamp},${lat},${lng},${accuracy},${altitude},${heading},${speed},${isNoisy}\n`;  
    });  
    
    return csv;  
  }  
  
  static async exportTrackLogsAsGeoJSON() {  
    const tracks = await this.getTrackLogs();  
    
    const geoJSON = {  
      type: 'FeatureCollection',  
      features: []  
    };  
    
    tracks.forEach(track => {  
      const coordinates = track.points.map(point => [point.coords.lng, point.coords.lat]);  
      
      geoJSON.features.push({  
        type: 'Feature',  
        geometry: {  
          type: 'LineString',  
          coordinates  
        },  
        properties: {  
          startTime: track.startTime,  
          endTime: track.endTime,  
          duration: track.duration,  
          pointCount: track.pointCount,  
          createdAt: track.createdAt  
        }  
      });  
    });  
    
    return JSON.stringify(geoJSON, null, 2);  
  }  
  
    // تعداد لاگ‌های ذخیره شده  
  static async getLogCounts() {  
    try {  
      const db = await this.initDB();  
      
      const gpsCountPromise = new Promise((resolve, reject) => {  
        const transaction = db.transaction([this.GPS_LOGS_STORE], 'readonly');  
        const store = transaction.objectStore(this.GPS_LOGS_STORE);  
        const countRequest = store.count();  
        
        countRequest.onsuccess = () => {  
          resolve(countRequest.result);  
        };  
        
        countRequest.onerror = (event) => {  
          reject(event.target.error);  
        };  
      });  
      
      const trackCountPromise = new Promise((resolve, reject) => {  
        const transaction = db.transaction([this.TRACK_LOGS_STORE], 'readonly');  
        const store = transaction.objectStore(this.TRACK_LOGS_STORE);  
        const countRequest = store.count();  
        
        countRequest.onsuccess = () => {  
          resolve(countRequest.result);  
        };  
        
        countRequest.onerror = (event) => {  
          reject(event.target.error);  
        };  
      });  
      
      const [gpsCount, trackCount] = await Promise.all([gpsCountPromise, trackCountPromise]);  
      
      return {  
        gpsLogs: gpsCount,  
        trackLogs: trackCount  
      };  
    } catch (err) {  
      console.error('خطا در دریافت تعداد لاگ‌ها:', err);  
      
      // فول‌بک به localStorage  
      const gpsLogs = JSON.parse(localStorage.getItem('gps_logs') || '[]');  
      const trackLogs = JSON.parse(localStorage.getItem('track_logs') || '[]');  
      
      return {  
        gpsLogs: gpsLogs.length,  
        trackLogs: trackLogs.length  
      };  
    }  
  }  
  
  // تخمین حجم داده‌های ذخیره شده (به بایت)  
  static async estimateStorageSize() {  
    try {  
      // نمونه‌برداری از 10 لاگ آخر برای تخمین میانگین سایز  
      const logs = await this.getGPSLogs(10);  
      const tracks = await this.getTrackLogs();  
      tracks.splice(10); // فقط 10 مورد آخر  
      
      const logsJson = JSON.stringify(logs);  
      const tracksJson = JSON.stringify(tracks);  
      
      const avgLogSize = logs.length > 0 ? logsJson.length / logs.length : 0;  
      const avgTrackSize = tracks.length > 0 ? tracksJson.length / tracks.length : 0;  
      
      const counts = await this.getLogCounts();  
      
      return {  
        gpsLogsSize: Math.round(avgLogSize * counts.gpsLogs),  
        trackLogsSize: Math.round(avgTrackSize * counts.trackLogs),  
        totalSize: Math.round(avgLogSize * counts.gpsLogs + avgTrackSize * counts.trackLogs)  
      };  
    } catch (err) {  
      console.error('خطا در تخمین حجم دیتابیس:', err);  
      return {  
        gpsLogsSize: 0,  
        trackLogsSize: 0,  
        totalSize: 0  
      };  
    }  
  }    
  
  // دانلود فایل  
  static downloadFile(content, filename, mimeType) {  
    const blob = new Blob([content], { type: mimeType });  
    const url = URL.createObjectURL(blob);  
    const a = document.createElement('a');  
    a.href = url;  
    a.download = filename;  
    document.body.appendChild(a);  
    a.click();  
    document.body.removeChild(a);  
    URL.revokeObjectURL(url);  
  }  
}  ```   
   
## \src\services\SignalProcessor.js   
```javascript   
// src/services/SignalProcessor.js  

/**  
 * سرویس برای پردازش سیگنال سنسورها و تشخیص رویدادها  
 */  
class SignalProcessor {  
    constructor() {  
      // تشخیص گام  
      this.stepDetectorThreshold = 0.5; // آستانه تشخیص گام (بزرگی شتاب)  
      this.peakDetectionThreshold = 0.2; // حداقل فاصله زمانی بین گام‌ها (ثانیه)  
      this.lastPeakTimestamp = 0;  
      this.accelerationMagnitudeHistory = []; // تاریخچه بزرگی شتاب  
      this.historySize = 50; // اندازه تاریخچه برای تشخیص گام پیشرفته (اختیاری)  
    }  
  
    /**  
     * بازنشانی پردازشگر سیگنال  
     */  
    reset() {  
      this.lastPeakTimestamp = 0;  
      this.accelerationMagnitudeHistory = [];  
    }  
  
    /**  
     * تشخیص گام بر اساس داده‌های شتاب‌سنج  
     * @param {object} acceleration داده‌های شتاب‌سنج (بدون گرانش)  
     * @param {number} timestamp زمان دریافت داده  
     * @returns {boolean} true اگر گام تشخیص داده شود، false در غیر این صورت  
     */  
    detectStep(acceleration, timestamp) {  
      const magnitude = Math.sqrt(  
        acceleration.x * acceleration.x +   
        acceleration.y * acceleration.y +   
        acceleration.z * acceleration.z  
      );  
      
      // اضافه کردن به تاریخچه (اختیاری برای الگوریتم‌های پیشرفته)  
      this.accelerationMagnitudeHistory.push(magnitude);  
      if (this.accelerationMagnitudeHistory.length > this.historySize) {  
          this.accelerationMagnitudeHistory.shift();  
      }  
  
      const timeSinceLastPeak = (timestamp - this.lastPeakTimestamp) / 1000;  
  
      // الگوریتم ساده مبتنی بر آستانه  
      if (magnitude > this.stepDetectorThreshold && timeSinceLastPeak > this.peakDetectionThreshold) {  
        this.lastPeakTimestamp = timestamp;  
        return true;  
      }  
      
      // می‌توان الگوریتم‌های پیشرفته‌تری را در اینجا پیاده‌سازی کرد:  
      // - تحلیل فرکانس (FFT) برای یافتن فرکانس گام  
      // - تشخیص قله (Peak Detection) با استفاده از تاریخچه سیگنال  
      // - مدل‌های یادگیری ماشین برای تشخیص الگوی گام  
  
      return false;  
    }  
  
    // متدهای دیگر برای پردازش سیگنال (اختیاری)  
    // - محاسبه سرعت از انتگرال شتاب  
    // - تخمین جهت بر اساس میدان مغناطیسی و شتاب گرانش (نیاز به داده‌های خام مگنتومتر و شتاب با گرانش)  
  }  
  
  export default SignalProcessor;  ```   
   
## \src\store\gpsStore.js   
```javascript   
import { create } from 'zustand';  
import { persist } from 'zustand/middleware';  

export const useGPSStore = create(  
  persist(  
    (set, get) => ({  
      currentLocation: null,  
      locationHistory: [],  
      savedLocations: [],  
      qrCodeLocations: [],  
      isTracking: false,  
      routeInfo: null,  
      
      // به‌روزرسانی موقعیت فعلی  
      updateCurrentLocation: (location) => set({ currentLocation: location }),  
      
      // افزودن موقعیت به تاریخچه  
      addLocationToHistory: (location) => set(state => ({  
        locationHistory: [...state.locationHistory, { ...location, id: Date.now() }]  
      })),  
      
      // ذخیره موقعیت  
      saveLocation: (location, name) => set(state => ({  
        savedLocations: [...state.savedLocations, {   
          ...location,   
          id: Date.now(),   
          name: name || `مکان ${state.savedLocations.length + 1}`   
        }]  
      })),  
      
      // ذخیره موقعیت QR Code  
      addQRCodeLocation: (qrData, location) => set(state => ({  
        qrCodeLocations: [...state.qrCodeLocations, {  
          id: Date.now(),  
          qrData,  
          location,  
          scannedAt: new Date().toISOString()  
        }]  
      })),  
      
      // شروع/توقف ردیابی  
      toggleTracking: () => set(state => ({ isTracking: !state.isTracking })),  
      
      // تنظیم اطلاعات مسیر  
      setRouteInfo: (routeInfo) => set({ routeInfo }),  
      
      // پاک‌کردن تاریخچه موقعیت  
      clearLocationHistory: () => set({ locationHistory: [] }),  
      
      // حذف یک موقعیت ذخیره‌شده  
      deleteSavedLocation: (id) => set(state => ({  
        savedLocations: state.savedLocations.filter(loc => loc.id !== id)  
      })),  
    }),  
    {  
      name: 'gps-storage',  
      version: 1,  
    }  
  )  
);  ```   
   
## \src\styles\DeadReckoning.css   
```javascript   
.dr-controls {  
  position: absolute;  
  bottom: 140px; /* بالاتر از کنترل‌های اصلی */  
  right: 10px;  
  z-index: 1000;  
  display: flex;  
  flex-direction: column;  
  gap: 8px;  
  direction: rtl;  
}  

.dr-toggle-button,  
.dr-calibrate-button,  
.dr-export-button {  
  display: flex;  
  align-items: center;  
  justify-content: center;  
  gap: 8px;  
  padding: 8px 12px;  
  border-radius: 8px;  
  background-color: #fff;  
  color: #333;  
  border: none;  
  box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);  
  font-family: inherit;  
  font-size: 0.9rem;  
  cursor: pointer;  
}  

.dr-toggle-button.active {  
  background-color: #4CAF50;  
  color: white;  
}  

.dr-calibrate-button {  
  background-color: #2196F3;  
  color: white;  
}  

.dr-export-button {  
  background-color: #FF9800;  
  color: white;  
}  

.dr-controls button:disabled {  
  opacity: 0.5;  
  cursor: not-allowed;  
}  

.step-counter {  
  display: flex;  
  align-items: center;  
  gap: 5px;  
  font-size: 0.85rem;  
  color: #333;  
}  

/* استایل برای مسیر Dead Reckoning روی نقشه */  
.dead-reckoning-path {  
  stroke: #4CAF50;  
  stroke-width: 4;  
  stroke-dasharray: 5, 5;  
  fill: none;  
  opacity: 0.8;  
}  ```   
   
## \src\utils\gpsFilter.js   
```javascript   
// src/utils/gpsFilter.js  
// فاصله هاوِرساین بین دو نقطه جغرافیایی (به متر)  
const calculateDistance = (lat1, lon1, lat2, lon2) => {  
  const R = 6371e3; // شعاع زمین به متر  
  const φ1 = lat1 * Math.PI / 180;  
  const φ2 = lat2 * Math.PI / 180;  
  const Δφ = (lat2 - lat1) * Math.PI / 180;  
  const Δλ = (lon2 - lon1) * Math.PI / 180;  

  const a = Math.sin(Δφ / 2) * Math.sin(Δφ / 2) +  
          Math.cos(φ1) * Math.cos(φ2) *  
          Math.sin(Δλ / 2) * Math.sin(Δλ / 2);  
  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));  
  return R * c;  
};  

export const isValidGPSReading = (current, previous) => {  
  if (!previous || !current) return true;  
  
  // بررسی وجود مختصات معتبر  
  if (!previous.coords || !current.coords ||  
      !previous.coords.lat || !previous.coords.lng ||  
      !current.coords.lat || !current.coords.lng) {  
    console.log('مختصات ناقص یا نامعتبر');  
    return true; // فرض بر معتبر بودن در صورت نامشخص بودن  
  }  
  
  // محاسبه فاصله بین دو نقطه  
  const distance = calculateDistance(  
    previous.coords.lat, previous.coords.lng,  
    current.coords.lat, current.coords.lng  
  );  
  
  // محاسبه زمان (اگر زمان نامعتبر باشد، فرض بر معتبر بودن داده)  
  if (!previous.timestamp || !current.timestamp) return true;  
  
  const timeDiff = (current.timestamp - previous.timestamp) / 1000;  
  if (timeDiff <= 0) return true; // زمان نامعتبر است  
  
  // سرعت (متر بر ثانیه)  
  const speed = distance / timeDiff;  
  
  console.log(`فاصله: ${distance.toFixed(2)}m, زمان: ${timeDiff.toFixed(2)}s, سرعت: ${speed.toFixed(2)}m/s`);  
  
  // اگر سرعت بیش از 5 متر بر ثانیه باشد، غیر معقول است  
  if (speed > 5) {  
    console.log('سرعت غیرمعقول - داده فیلتر شد');  
    return false;  
  }  
  
  // اگر فاصله بیش از 50 متر باشد و زمان کمتر از 5 ثانیه  
  if (distance > 50 && timeDiff < 5) {  
    console.log('پرش موقعیت - داده فیلتر شد');  
    return false;  
  }  
  
  return true;  
};  

// صدور تابع محاسبه فاصله برای استفاده در جاهای دیگر  
export { calculateDistance };  ```   
   
## \src\utils\HighPassFilter.js   
```javascript   
// src/services/utils/HighPassFilter.js  
/**  
 * فیلتر بالاگذر برای حذف تغییرات آهسته (مانند شتاب جاذبه)  
 */  
export class HighPassFilter {  
    /**  
     * @param {number} alpha ضریب فیلتر (0-1). مقادیر بزرگتر فیلترینگ بیشتری اعمال می‌کنند.  
     */  
    constructor(alpha = 0.8) {  
      this.alpha = alpha;  
      this.lastValues = {};  
      this.lastFilteredValues = {};  
    }  
    
    /**  
     * فیلتر کردن یک مقدار  
     * @param {number} value مقدار جدید  
     * @param {string} key کلید برای ذخیره مقادیر آخر (برای کانال‌های مختلف)  
     * @returns {number} مقدار فیلتر شده  
     */  
    filter(value, key = 'default') {  
      // اگر اولین مقدار است، آن را به عنوان مقدار آخر ذخیره کنید  
      if (this.lastValues[key] === undefined) {  
        this.lastValues[key] = value;  
        this.lastFilteredValues[key] = 0;  
        return 0;  
      }  
      
      // اعمال فیلتر بالاگذر: y[n] = α·(y[n-1] + x[n] - x[n-1])  
      const filteredValue = this.alpha * (  
        this.lastFilteredValues[key] + value - this.lastValues[key]  
      );  
      
      // به‌روزرسانی مقادیر آخر  
      this.lastValues[key] = value;  
      this.lastFilteredValues[key] = filteredValue;  
      
      return filteredValue;  
    }  
    
    /**  
     * بازنشانی فیلتر  
     */  
    reset() {  
      this.lastValues = {};  
      this.lastFilteredValues = {};  
    }  
  }  ```   
   
## \src\utils\LowPassFilter.js   
```javascript   
// src/services/utils/LowPassFilter.js  
/**  
 * فیلتر پایین‌گذر برای حذف نویز فرکانس بالا  
 */  
export class LowPassFilter {  
    /**  
     * @param {number} alpha ضریب فیلتر (0-1). مقادیر کوچکتر فیلترینگ بیشتری اعمال می‌کنند.  
     */  
    constructor(alpha = 0.1) {  
      this.alpha = alpha;  
      this.lastValues = {};  
    }  
    
    /**  
     * فیلتر کردن یک مقدار  
     * @param {number} value مقدار جدید  
     * @param {string} key کلید برای ذخیره مقدار آخر (برای کانال‌های مختلف)  
     * @returns {number} مقدار فیلتر شده  
     */  
    filter(value, key = 'default') {  
      // اگر اولین مقدار است، آن را به عنوان مقدار آخر ذخیره کنید  
      if (this.lastValues[key] === undefined) {  
        this.lastValues[key] = value;  
        return value;  
      }  
      
      // اعمال فیلتر: y[n] = α·x[n] + (1-α)·y[n-1]  
      const filteredValue = this.alpha * value + (1 - this.alpha) * this.lastValues[key];  
      this.lastValues[key] = filteredValue;  
      
      return filteredValue;  
    }  
    
    /**  
     * بازنشانی فیلتر  
     */  
    reset() {  
      this.lastValues = {};  
    }  
  }  ```   
   
## \src\utils\PeakDetector.js   
```javascript   
// src/services/utils/PeakDetector.js  
/**  
 * کلاس تشخیص پیک برای تشخیص قله‌ها در سیگنال  
 * مفید برای تشخیص گام و حرکات تکراری  
 */  
export class PeakDetector {  
    /**  
     * @param {Object} options تنظیمات  
     * @param {number} options.threshold آستانه تشخیص پیک  
     * @param {number} options.minPeakDistance حداقل فاصله زمانی بین پیک‌ها (میلی‌ثانیه)  
     * @param {number} options.windowSize تعداد نمونه‌هایی که برای تشخیص پیک بررسی می‌شوند  
     */  
    constructor(options = {}) {  
      this.threshold = options.threshold || 1.0;  
      this.minPeakDistance = options.minPeakDistance || 500;  
      this.windowSize = options.windowSize || 10;  
      
      this.samples = [];  
      this.lastPeakTime = 0;  
    }  
    
    /**  
     * افزودن یک نمونه جدید و بررسی تشخیص پیک  
     * @param {number} value مقدار نمونه  
     * @param {number} timestamp زمان نمونه (میلی‌ثانیه)  
     * @returns {boolean} آیا پیک تشخیص داده شده است  
     */  
    addSample(value, timestamp) {  
      // افزودن نمونه جدید  
      this.samples.push({ value, timestamp });  
      
      // حفظ فقط چند نمونه آخر  
      if (this.samples.length > this.windowSize * 2) {  
        this.samples.shift();  
      }  
      
      // نیاز به حداقل چند نمونه برای تشخیص پیک  
      if (this.samples.length < this.windowSize) {  
        return false;  
      }  
      
      // بررسی فاصله زمانی از آخرین پیک  
      if (timestamp - this.lastPeakTime < this.minPeakDistance) {  
        return false;  
      }  
      
      // بررسی اینکه آیا نمونه‌های میانی بزرگتر از آستانه هستند و پیک محسوب می‌شوند  
      const midIndex = Math.floor(this.samples.length / 2);  
      const midSample = this.samples[midIndex];  
      
      // شرایط تشخیص پیک:  
      // 1. مقدار باید بزرگتر از آستانه باشد  
      if (midSample.value < this.threshold) {  
        return false;  
      }  
      
      // 2. مقدار باید بزرگتر از همه نمونه‌های قبلی باشد  
      for (let i = 0; i < midIndex; i++) {  
        if (this.samples[i].value >= midSample.value) {  
          return false;  
        }  
      }  
      
      // 3. مقدار باید بزرگتر از همه نمونه‌های بعدی باشد  
      for (let i = midIndex + 1; i < this.samples.length; i++) {  
        if (this.samples[i].value >= midSample.value) {  
          return false;  
        }  
      }  
      
      // پیک تشخیص داده شد  
      this.lastPeakTime = timestamp;  
      return true;  
    }  
    
    /**  
     * بازنشانی تشخیص‌گر پیک  
     */  
    reset() {  
      this.samples = [];  
      this.lastPeakTime = 0;  
    }  
  }  ```   
   
## \src\utils\useGPSNoiseDetection.js   
```javascript   
// src/utils/useGPSNoiseDetection.js  
import { useState, useEffect } from 'react';  
import { calculateDistance } from './gpsFilter';  

// محاسبه زاویه بین دو نقطه (برای تشخیص تغییر جهت)  
const calculateBearing = (lat1, lon1, lat2, lon2) => {  
  const φ1 = lat1 * Math.PI / 180;  
  const φ2 = lat2 * Math.PI / 180;  
  const Δλ = (lon2 - lon1) * Math.PI / 180;  

  const y = Math.sin(Δλ) * Math.cos(φ2);  
  const x = Math.cos(φ1) * Math.sin(φ2) -  
          Math.sin(φ1) * Math.cos(φ2) * Math.cos(Δλ);  

  return Math.atan2(y, x) * 180 / Math.PI;  
};  

// تشخیص تغییر جهت ناگهانی  
const isSharpTurn = (bearing1, bearing2) => {  
  let diff = Math.abs(bearing2 - bearing1);  
  if (diff > 180) diff = 360 - diff;  
  return diff > 120; // تغییر بیش از 120 درجه  
};  

export const useGPSNoiseDetection = (locationHistory, currentLocation) => {  
  // وضعیت‌های مختلف  
  const [isJamming, setIsJamming] = useState(false);  
  const [isAccuracyLow, setIsAccuracyLow] = useState(false);  
  const [isSpeedUnrealistic, setIsSpeedUnrealistic] = useState(false);  
  const [isPositionJumping, setIsPositionJumping] = useState(false);  
  const [anomalyScore, setAnomalyScore] = useState(0); // امتیاز نویز بین 0 تا 100  
  
  // تنظیمات و آستانه‌ها  
  const UNREALISTIC_SPEED_THRESHOLD = 5; // متر بر ثانیه (18 کیلومتر بر ساعت)  
  const POSITION_JUMP_THRESHOLD = 50; // متر  
  const LOW_ACCURACY_THRESHOLD = 50; // متر  
  const MEASUREMENT_WINDOW = 5; // تعداد نقاط برای تحلیل  

  useEffect(() => {  
    // بررسی وجود داده‌های کافی برای تحلیل  
    if (!locationHistory || !Array.isArray(locationHistory) || locationHistory.length < 1 || !currentLocation) {  
      console.log('داده‌های کافی برای تحلیل وجود ندارد', {   
        hasHistory: !!locationHistory,   
        historyLength: locationHistory?.length || 0,   
        hasCurrent: !!currentLocation   
      });  
      return;  
    }  

    // نمایش اطلاعات اولیه برای دیباگ  
    console.log('تحلیل کیفیت GPS با', locationHistory.length, 'نقطه در تاریخچه');  
    
    // بررسی آخرین نقطه با نقطه قبلی  
    let jumpDetected = false;  
    let unrealisticSpeedDetected = false;  
    let lowAccuracyDetected = false;  
    let score = 0;  

    // بررسی دقت موقعیت فعلی  
    if (currentLocation.coords && currentLocation.coords.accuracy) {  
      if (currentLocation.coords.accuracy > LOW_ACCURACY_THRESHOLD) {  
        lowAccuracyDetected = true;  
        score += 20;  
        console.log(`دقت پایین: ${currentLocation.coords.accuracy.toFixed(2)} متر`);  
      }  
    }  

    // اگر بیش از یک نقطه در تاریخچه داریم، می‌توانیم سرعت و پرش را محاسبه کنیم  
    if (locationHistory.length > 0) {  
      const previous = locationHistory[locationHistory.length - 1];  
      
      if (previous && previous.coords && currentLocation && currentLocation.coords) {  
        // بررسی وجود مختصات معتبر  
        if (previous.coords.lat && previous.coords.lng &&   
            currentLocation.coords.lat && currentLocation.coords.lng) {  
          
          // محاسبه فاصله  
          const distance = calculateDistance(  
            previous.coords.lat, previous.coords.lng,  
            currentLocation.coords.lat, currentLocation.coords.lng  
          );  

          // محاسبه زمان (به ثانیه)  
          const timeDiff = (currentLocation.timestamp - previous.timestamp) / 1000;  
          
          // فقط اگر زمان معتبر است محاسبه کنیم  
          if (timeDiff > 0) {  
            // محاسبه سرعت (متر بر ثانیه)  
            const speed = distance / timeDiff;  
            
            console.log(`فاصله: ${distance.toFixed(2)}m, زمان: ${timeDiff.toFixed(2)}s, سرعت: ${speed.toFixed(2)}m/s`);  

            // بررسی پرش موقعیت  
            if (distance > POSITION_JUMP_THRESHOLD && timeDiff < 5) {  
              jumpDetected = true;  
              score += 30;  
              console.log('پرش موقعیت شناسایی شد');  
            }  

            // بررسی سرعت غیرعادی  
            if (speed > UNREALISTIC_SPEED_THRESHOLD) {  
              unrealisticSpeedDetected = true;  
              score += 30;  
              console.log('سرعت غیرمعقول شناسایی شد');  
            }  

            // محاسبه جهت برای تشخیص تغییر ناگهانی (اگر بیشتر از 2 نقطه داریم)  
            if (locationHistory.length > 1) {  
              const beforePrevious = locationHistory[locationHistory.length - 2];  
              if (beforePrevious && beforePrevious.coords &&   
                  beforePrevious.coords.lat && beforePrevious.coords.lng) {  
                
                const previousBearing = calculateBearing(  
                  beforePrevious.coords.lat, beforePrevious.coords.lng,  
                  previous.coords.lat, previous.coords.lng  
                );  
                
                const currentBearing = calculateBearing(  
                  previous.coords.lat, previous.coords.lng,  
                  currentLocation.coords.lat, currentLocation.coords.lng  
                );  
                
                if (isSharpTurn(previousBearing, currentBearing) && distance > 5) {  
                  score += 20;  
                  console.log('تغییر جهت ناگهانی شناسایی شد');  
                }  
              }  
            }  
          } else {  
            console.log('فاصله زمانی نامعتبر:', timeDiff);  
          }  
        } else {  
          console.log('مختصات ناقص در نقاط:', {   
            prevLat: previous.coords.lat,   
            prevLng: previous.coords.lng,  
            currLat: currentLocation.coords.lat,   
            currLng: currentLocation.coords.lng   
          });  
        }  
      } else {  
        console.log('ساختار داده نقاط ناقص است');  
      }  
    }  

    // محدود کردن امتیاز به حداکثر 100  
    score = Math.min(score, 100);  
    console.log('امتیاز نویز GPS:', score);  
    
    // به‌روزرسانی وضعیت‌ها  
    setIsPositionJumping(jumpDetected);  
    setIsSpeedUnrealistic(unrealisticSpeedDetected);  
    setIsAccuracyLow(lowAccuracyDetected);  
    
    // اگر امتیاز بالای 50 باشد، احتمالاً جمر است  
    setIsJamming(score > 50);  
    setAnomalyScore(score);  

  }, [locationHistory, currentLocation]);  

  return {  
    isJamming,  
    isAccuracyLow,  
    isSpeedUnrealistic,  
    isPositionJumping,  
    anomalyScore,  
    noiseLevel: anomalyScore < 20 ? 'کم' : anomalyScore < 50 ? 'متوسط' : 'زیاد'  
  };  
};  ```   
   
